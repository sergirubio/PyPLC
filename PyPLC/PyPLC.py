#       "$Name:  $";
#       "$Header: /cvsroot/tango-ds/InputOutput/PyPLC/PyPLC.py,v 1.15 2012/03/20 09:09:30 sergi_rubio Exp $";
#=============================================================================
#
# file :        PyPLC.py
#
# description : Python source for the PyPLC and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyPLC are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  DynamicDS and ModbusCommunications: Sergi Rubio i Manrique, srubio@cells.es; 
#            Commands and DataType management: Maciej Niegowski, mniegowski@cells.es $
#
# $Revision: 1.15 $
#
# $Log: PyPLC.py,v $
# Revision 1.15  2012/03/20 09:09:30  sergi_rubio
# using DynamicDS.set_state to push events
# State management modified in PyPLC to avoid State set by qualities
# explicitly added all DynamicDS properties to PyPLC
# Added DynamicCommands
# KeepAttributes,KeepTime,CheckDependencies will have its own default values for PyPLC
# Static/Mapping attributes not require polling to be up to date
#
# Revision 1.14  2011/03/23 10:33:18  sergi_rubio
# Added Mapping attributes to StaticAttributes list to be kept after an updateDynamicAttributes call.
# StateMachine() will be called once per second as much.
# import_info() calls have been removed from checkModbus to avoid DB overload.
#
# Revision 1.13  2011/03/01 19:07:22  sergi_rubio
#  * init refactoring
#
#  * solve errors in flags (Flag,!WriteFlag,!WriteBit)
#
#  * code cleanup
#
#  * thread_stop() in delete_device
#
#  * traces cleanup
#
#  * do not allow to read_mapped until all addresses read
#
#  * Binary2Denary/negBinary/Denary2Binary refactored
#
# Revision 1.12  2011/01/26 16:00:08  sergi_rubio
#
# Removed double quotes from commands dictionary.
#
# Revision 1.10  2009/01/15 16:01:20  sergi_rubio
# Modbus class should not be loaded by default, call to add_Cpp_TgClass commented
#
# Revision 1.9  2009/01/15 15:56:19  sergi_rubio
# *** empty log message ***
#
# Revision 1.8  2009/01/15 15:54:25  sergi_rubio
# WriteBit command deprecated by WriteFlag (although some backward compatibility will be provided temporarily)
#
# Bug solved in WriteFlag ... second argument now can be either int, float or string when called in DynamicAttributes declaration
#
# Revision 1.7  2008/12/18 17:09:35  sergi_rubio
# Refactoring in the initialization of the device.
# Added new property LogLevel and command SetLogLevel
#
# Revision 1.6  2008/11/13 09:39:37  taurel
# - Fix a small bug in the Coils command. The Modbus class command name
# was wrong (missing xxxMultipleCoil instead of xxxMultipleCoils)
#
# Revision 1.5  2008/11/05 17:46:49  sergi_rubio
# General refactoring of the class.
# ALBA exclusive stuff has been removed (a separate class AlbaPLC implements it).
# These release requires to checkout the last release of fandango
#
# Revision 1.4  2008/06/30 15:10:34  sergi_rubio
# Refactoring of PyPLC, new PLCValve abstract device added.
#
# Revision 1.3  2008/05/16 10:19:37  sergi_rubio
# Dozen of changes in the PyPLC and fandango modules, documentation seriously improved.
#
# Revision 1.1.1.1  2007/11/14 09:57:13  sergi_rubio
# The Device Server for Modbus PLCs
#
#
# copyleft :    ALBA Synchrotron
#               www.cells.es
#               Barcelona, EU
#
#=============================================================================
#               This file is generated by POGO
#       (Program Obviously used to Generate tango Object)
#
#         (c) - Controls Section - ALBA
#=============================================================================
#


import PyTango
import sys,time,inspect,threading,struct,re,traceback

## This device server requires Fandango
# https://github.com/tango-controls/fandango

import fandango
from fandango import DynamicDS,DynamicDSClass,Logger,\
  getLastException,Catched,printf
import fandango.functional as fun
from fandango.functional import *
from fandango.objects import Cached

from PyTango import DevState
from ModbusMap import ModbusMap,ModbusArray,ModbusMapException

#Patches between PyTango3 and PyTango7
if 'PyUtil' not in dir(PyTango): 
    PyTango.PyDeviceClass = PyTango.DeviceClass
    PyTango.PyUtil = PyTango.Util
if 'Device_4Impl' not in dir(PyTango):
    PyTango.Device_4Impl = PyTango.Device_3Impl
    
PyPLC__doc__ = """<pre>
#==================================================================
#   PyPLC Class Description:
#
#         <p>This device server will allow to interact with the Modbus PLC's.
#         The target is reading and writing variables and input/outputs of the PLC
#         by using Tango Attributes. Tango Attributes will be generated dynamically 
#         using this syntax:<br>
#         <p><pre>T3=int(Reg(7007)/10.)</pre></p>
#         <p>The commands Coil, Flag, Reg and fReg will allow to declare
#         Digital, Bit, Integer and Float variables respectively.</p>
#         <p>See full description at <a href="http://www.tango-controls.org/Members/srubio/pyplc-device-server">www.tango-controls.org</a></p>
#         <p>This device requires <a href="http://www.tango-controls.org/Documents/tools/fandango/fandango">Fandango module<a> to be available in the PYTHONPATH.
#
#==================================================================
#     Device States Description:
#
#   DevState.INIT :
#   DevState.ON :
#   DevState.ALARM :
#   DevState.FAULT :
#==================================================================

=== How Mapping works ===

Mapping property define a set of formula/comands/addresses that identify memory-mapped regions

This mappings will be accessible both by name and by modbus addresses, keeping a cache of values.

Modbus Commands to update Mappings will be executed by a background thread. 

Every time that a Modbus command is returned by the thread the Mapping flag will be enabled, telling
the device to execute ReadMap to update the cache values.

</pre>""".replace('#','')


class PyPLC(PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------

    __doc__ = PyPLC__doc__
        
    
    #This variable will limit the size of HoldingRegisters queries
    MAX_REGS_LENGTH = 120 #Changed by roberto suggestion; 30/April/2009
    
    ## Data conversion commands---------------------------------------------------
    
    #@Catched
    @staticmethod
    def negBinary(old):
        """ Given a binary number as an string, it returns all bits negated """
        return ''.join(('0','1')[x=='0'] for x in old)

    @staticmethod
    def Denary2Binary(x,N=16):
        """ It converts an integer to an string with its binary representation 
        """ 
        if x>=0: bStr = bin(int(x))
        else: bStr = bin(int(x)%2**16)
        bStr = bStr.replace('0b','')
        if len(bStr)<N: bStr='0'*(N-len(bStr))+bStr
        return bStr[-N:]
    
    Dec2Bin = Denary2Binary
    
    @staticmethod
    def Binary2Denary(x,N=16):
        """ Converts an string with a binary number into a signed integer """
        i = int(x,2)
        if i>=2**(N-1): i=i-2**N
        return i
        
    @staticmethod
    def Exponent(n):
        """ Used in IeeeFloat type conversions, 
        Converts an array of 8 binary numbers in a signed integer. """
        sum = 0
        for x in range(0,8):
            sum += int(n[x])*pow(2,7-x)
        if sum == 0: return '0'
        sum = sum - 127
        return sum

    @staticmethod
    def Significand(n):
        """ Used in IeeeFloat type conversions """
        sum = 0.0
        pot = 1.0
        for x in range(0,24):
            sum += int(n[x])*pot/pow(2,x)
        return sum
        
    @staticmethod
    def Dec2Bits(dec,nbits=16):
        """ Decimal to binary converter """
        result,dec = [],int(dec)
        for i in range(nbits):
            result.append(bool(dec % 2))
            dec = dec >> 1
        return result        
        
    @staticmethod
    def Ints2Float(arg):
        """ Converts an array of 2 integers into an IeeeFloat number """

        reg1,reg2 = int(arg[0]),int(arg[1])
        import struct,traceback
        try:
            p = struct.pack('hh', reg1, reg2)
            argout = struct.unpack('f', p )[0]
        except:
            print('Ints2Float(%s) failed!'%str(arg))
            traceback.print_exc()
        
        #argout = struct.unpack('d', struct.pack('LL', reg1, reg2) )[0]
        
        ##Match 0 values
        #bla = int(arg[1])
        #if bla  == 0 and int(arg[0]) == 0: 
            #return 0.0
        #elif int(arg[0]) == -22939 and bla == 11195: 
            #return 0.0

        ##Convert high bytes
        #if bla >= 0: 
            #highval = PyPLC.Denary2Binary(bla)
        #else:
            #bla = (-1)*bla
            ##"The bin value of the absolute: ",temp
            #temp = PyPLC.Denary2Binary(bla) 
            ##"The bin high value of the reverse: ", highval
            #highval = PyPLC.negBinary(temp) 
            
        ##Convert low bytes
        #bla = int(arg[0])
        #if bla >= 0: 
            #lowval = PyPLC.Denary2Binary(bla)
        #else:
            #bla = (-1)*bla;
            ##print "The bin value of the absolute: ",temp
            #temp = PyPLC.Denary2Binary(bla)
            ##print "The bin low value of the reverse: ", lowval
            #lowval = PyPLC.negBinary(temp) 

        ##Build result
        #highval = highval + lowval

        #sign = int(highval[0])
        #sign1 = 1 if not sign else -1

        #expo = highval[1:9]
        #mant = '1' + highval[9:]

        #ex = int(PyPLC.Exponent(expo))
        #si = float(PyPLC.Significand(mant))
        #argout= float(sign1*pow(2,ex)*si)

        return argout
        
    # -----------------------------------------------------------------------------
    ## Threaded behaviour methods --------------------------------
    
    def initThreadDict(self):
        """
        It creates a ThreadDict, a dictionary of modbus commands 
        which results will be updated periodically.
        All registers used by Mappings are by default added as keys.
        For each key it will execute a ReadHoldingRegisters modbus command,
        """
        def read_method(args,comm=self.Regs,log=self.debug):
            try:
                #log('>'*20 + ' In ThreadDict.read_method(%s)' % args)
                args = args.split(',')
                # args = Address, Length <, Command>
                args = [int(s) for s in args[:2]]+[s for s in args[2:]]
                ## ASYNCH IS USED TO DIFFERENTIATE THREAD CALLS FROM CLIENT CALLS
                # So, asynch=False here will stop the thread and read nothing
                result = comm(args,asynch=True)
                return result
            except PyTango.DevFailed,e:
                print('Exception in ThreadDict.read_method!!!'
                    +'\n'+str(e).replace('\n','')[:100])
            except Exception,e:
                print('#'*80+'\n'+'Exception in ThreadDict.read_method!!!'
                      +'\n'+traceback.format_exc()+'\n'+'#'*80)
                # Arrays shouldnt be readable if communication doesn't work!
                return [] 
            
        self.threadDict = fandango.ThreadDict(
            read_method = read_method,
            timewait=max(0.01,self.ModbusTimeWait/1000.)
            )#trace=True)
        
        for var,maps in self.MapDict.items():
            md = self.MapDict[var]
            regs = md.commands
            for reg in regs:
                vals = ','.join(str(r) for r in reg)
                self.debug('Adding %s(%s) as ThreadDict[%s]' % (var,reg,vals))
                self.threadDict.append(vals,value=[],period=md.period)#period=[])
        
        #self.threadDict.start() #moved to always_executed_hook
        self.info('out of PyPLC.initThreadDict()'+'\n'+'-'*80)
        
    # -------------------------------------------------------------------------

    def parseMappingProperty(self,mapping=None,update=False):
        """
        Parsing the Mapping property and initializing MapDict dictionaries.
        """
        mapdict,mapping = {},mapping if mapping is not None else self.Mapping
        self.debug('In parseMappingProperty(%s,%s)'%(mapping,update))
        if update: 
            if not getattr(self,'MapDict',None): 
                self.MapDict = ModbusMap()
            else: 
                self.MapDict.clear()
            self.maps_failed = []
            target = self.MapDict
        else: target = ModbusMap()
        try:
            target.load(mapping)
            mapdict = target.asDict()
            if update:
                for v in target.values():
                    for a in (self.DynamicAttributes,self.StaticAttributes):
                        if v.attribute not in a: a.append(v.attribute)
                self._locals['MapDict'] = self._locals['Mapping'] = self.MapDict
                
        except Exception,e:
            error = 'Unable to parse Mapping Property: %s'%(traceback.format_exc())
            self.init_errors.append(error), self.error(error)
        self.info("Mapping's read are: %s"%str(mapdict))
        return mapdict
        
    @Cached(depth=100,expire=0.05,log=True)
    def ReadMap(self,*args,**kwargs):
        '''
        Possible arguments are:

            1 string matching the name of a Mapping:
                The formula declared for Mapping will be used for the declaration

            1 string containing Regs() commands:
                The string is used like a simple attribute declaration; the attribute is evaluated.        

            2 integers (in 2 variables or in a list or tuple):
                These are understood as the starting and ending address to be read.
                Due to Modbus limitations it splits this Map reading in sets of 125 registers.

            callbacks = True/False; whether to call callbacks for this map
        '''
        #self.debug('>'*80)
        
        #@TODO: THIS METHOD SEEMS TO TRIGGER MEMORY LEAKS!!!
        
        t0 = time.time()
        if not args: raise Exception('ReadMap.ArgumentNeeded')
        result,attr = [],''
        
        # If the argument is the name of a Mapping we replace args and attr_name
        ## as called from always_executed_hook
        if args[0] in self.MapDict: 
            # In this case, formula = mapping
            attr,args = args[0],[self.MapDict[args[0]].formula] 
        
        callbacks = kwargs.get('callbacks', self.check_attribute_events(attr))
            
        # If first argument is not in map format, we evaluate it
        if len(args)==1 and isString(args[0]) and not ModbusArray.is_valid_map(args[0]):
            self.debug('ReadMap(%s,%s): Unrecognized format, returning a pure evaluation.'%(args,callbacks))
            # In this case, formula = list(long(r) for r in ReadMap("AnalogRealsREAD"))
            result = self.evalAttr(args[0])
            
        #Matching a declared mapping, two addresses or a list of Reg commands
        else:
            self.debug('In ReadMap(%s,%s,%s)'%(attr,args,callbacks))
            if attr: 
                regs = self.MapDict[attr].commands
            else: 
                regs = ModbusArray.GetCommands4Map(*args)

            self.debug('ReadMap: %d reg commands: %s = %s'%(len(regs),args,regs))
            if hasattr(self,'threadDict'): #reading in background thread
                self.debug('... reading in background thread')
                for reg in regs:
                    key = ','.join(str(r) for r in reg)
                    val = self.threadDict[key]
                    if isinstance(val,Exception):
                        raise Exception('Exception: %s[%s]: %s.' % (attr,key,str(val)) )

                    if val is None or not len(val):
                        raise ModbusMapException('ReadMapException:'
                            ' %s[%s] values has not been read yet.' % (attr,key) )
                    else:
                        result.extend(val)
                    #self.debug('Reading from ThreadDict[%s] = %s...'%(key,result[:10]))
            else: #reading registers immediately
                for t in regs:
                    c = getattr(self,t[2]) if len(t==3) else self.Regs
                    result.extend(c([t[0],t[1]]))
                self.debug('Reading from Modbus(%s) = %s ...' % (regs,result[:10]))
            
        #Keeping the value of Mapping for further reuse; even if the rest of attributes are not kept
        if attr in self.MapDict:
            #########################################################################
            self.dyn_values[attr].keep = True
            if isinstance(result,(Exception,TypeError)):
                self.warning('%s exception: %s' % (attr,result))
                result = None
                qual = PyTango.AttrQuality.ATTR_INVALID
            else:
                #Data conversion necessary to avoid numpy issues
                result = self.dyn_types[attr].pytype(result) 
                qual = PyTango.AttrQuality.ATTR_VALID
                
            prev = self.dyn_values[attr].value
            prev = None if isinstance(prev,(Exception,TypeError)) else prev
 
            changed = []
            for i,v in enumerate(result):
                if i>=len(prev or []) or v!=prev[i]:
                    changed.append(i)
            if len(prev or []) > len(result or []):
                changed.extend(range(len(result),len(prev)))

            self.debug('Updating %s cached values ([%d]=>[%d],%s)'
                %(attr,len(prev or []),len(result or []),isTrue(changed)))
            self.dyn_values[attr].update(result,self.MapDict[attr].time,qual)
            self.MapDict[attr].data = self.dyn_values[attr].value
            self._locals[attr] = result
            
            if changed and callbacks:
                self.warning('%s changed: %s' % (attr,changed))
                if self.MapDict[attr].callbacks is None:
                    for k,v in self.dyn_values.items():
                        if attr in v.dependencies \
                                and self.check_attribute_events(k):
                            try:
                                #r = attr+'\[([0-9]+)\]'
                                #rs = map(int,re.findall(r,v.formula))
                                # Array access parsing
                                cbs = list()
                                r = attr+'\[([0-9\+\-\:]+)\]'
                                r = [eval(s.replace(':',',')) for s in 
                                          re.findall(r,v.formula)]
                                for s in r:
                                    if isSequence(s):
                                        cbs.extend(range(int(s[0]),int(s[-1])))
                                    else:
                                        cbs.append(int(s))
                                        
                                self.info('%s: %s' % (k,cbs))
                                cbs.append(
                                    fandango.partial(self.evalAttr,push=True))
                            except:
                                self.warning(traceback.format_exc())

                            self.info('Add %s to %s callbacks: %s' 
                                      % (k,attr,cbs))
                            self.MapDict[attr].subscribe(k,cbs)
            
                if self.MapDict[attr].callbacks:
                    #self.info('Trigger %s callbacks: %s' 
                              #% (attr,self.MapDict[attr].callbacks.keys()))
                    regs = changed if isSequence(changed) else None
                    self.MapDict[attr].trigger_callbacks(regs)
            else:
                self.debug('... nothing changed ...')
            
            self.MapDict[attr].uncheck()

        self.debug( "Out of ReadMap(%s), it took %d ms" % (args,1e3*(time.time()-t0)))
        return result
                
    # -------------------------------------------------------------------------                
    
    def checkModbus(self):
        """ This method will check the modbus device and will throw exception if not available. """
        if not self.modbus:
            self.last_failed = time.time()
            self.last_exception,self.last_exception_time = "ModbusDeviceNotInitialized",self.last_failed
            raise Exception('ModbusDeviceNotInitialized(%s)'%self.Modbus_name)
        elif self.last_failed>self.last_communication:
            if not self.modbus.ping(): #Using ping to check device availability
                self.last_failed = time.time()
                self.last_exception,self.last_exception_time = "ModbusDeviceNotExportedException",self.last_failed
                raise Exception('ModbusDeviceNotExported(%s)'%self.Modbus_name)
        return True
                
    def sendModbusCommand(self,command,arr_argin,asynch=False):
        (self.debug  if asynch else printf)('In PyPLC.sendModbusCommand(%s,%s) ... %s' % (command,arr_argin,['Synch-EXTERNAL','Asynch-INTERNAL'][asynch]))
        result,retries,timeout,Xretries=None,3,1.,100.
        # WE WILL WAIT timeout/Xretries seconds between checking if the asynch has arrived
        self.last_try=time.time()
        if arr_argin is not None and len(arr_argin): arr_argin[0] += self.AddressOffset
        
        if self.ErrorTimeWait>1000*(self.last_try-self.last_failed):
            #PyTango.Except.throw_exception("TimeWAITBetweenRetries","Last communication failed at %s, waiting %s millis"%(time.ctime(self.last_failed),self.ErrorTimeWait),inspect.currentframe().f_code.co_name)
            raise Exception('%s (retry in %s ms)'%(self.last_exception,self.ErrorTimeWait))
        if not self.checkModbus(): #It will trigger an exception if Modbus is not reached
            return
        
        try:            
            ## If it is an external command (Synchronous) the threadDict must be stop to execute the external command first.
            ## ASYNCH IS USED TO DIFFERENTIATE THREAD CALLS FROM CLIENT CALLS
            if not asynch and hasattr(self,'threadDict'): 
                self.threadDict.stop()
            while retries:
                try:
                    if time.time()>(self.last_try+timeout):
                        r,retries = retries,0
                        raise Exception(self.last_exception if 'timeout' in str(self.last_exception).lower() 
                              else 'sendModbusCommand(%s,%s)(%s): Timeout! (%s,%s)'%(command,arr_argin,r,time2str(self.last_try),timeout))
                    if not asynch:
                        try: 
                            self.debug('In PyPLC.sendModbusCommand(...): Acquiring Modbus Lock ....')
                            self.modbusLock.acquire()
                            result=self.modbus.command_inout(command,arr_argin)
                        finally:
                            self.debug('In PyPLC.sendModbusCommand(...): Releasing Modbus Lock ....')
                            self.modbusLock.release()
                    else:
                        another_retries = Xretries
                        tw = timeout/Xretries
                        cid = self.modbus.command_inout_asynch(command,arr_argin)
                        #self.debug('In PyPLC.sendModbusCommand(...): Waiting %d*%d ms for asynchronous answer (cid=%s) ...' % (Xretries,int(1000*tw),cid))
                        while another_retries:
                            another_retries -= 1
                            fandango.wait(tw)
                            try:
                                self.modbusLock.acquire()
                                result = self.modbus.command_inout_reply(cid)
                                self.debug('Received: %s' % (str(result)[:50]+' ...'))
                                break
                            except PyTango.DevFailed,e:
                                if 'AsynReplyNotArrived' not in str(e):
                                    self.debug('Received DevFailed: %s' %e)
                                if another_retries == 0 or any(q in str(e) for q in ('DeviceTimedOut','BadAsynPollId')): #BadAsynPollId is received once the command is discarded
                                    raise Exception,'ModbusException_%s'%(str(e).replace('\n','')[:100])
                            finally:
                                self.modbusLock.release()
                                pass
                                
                    if self.MapDict: 
                        reg = arr_argin[0] if fun.isIterable(arr_argin) else arr_argin
                        maps = [k for k,v in self.MapDict.items() if v.has_address(reg)]
                        self.debug('checking mappings for %s: %s'%(reg,maps))
                        for k in maps:
                            self.MapDict[k].check()
                            #if (self.get_state() not in (DevState.INIT, DevState.UNKNOWN) and \
                            if time.time() > (self.time0 + 2e-3*self.DEFAULT_POLLING_PERIOD):
                                try:
                                    self.ReadMap(k,callbacks=True)
                                except Exception as e:
                                    self.warning('unable to readmap(%s):\n%s'%(k,traceback.format_exc()))
                                
                    self.last_exception = ''
                except Exception,e:
                    retries-=1
                    self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
                    (retries and self.debug or self.warning)(self.get_name()+"::sendModbusCommand: Exception!(%d retries left): %s" % (retries,str(e)))
                    if retries<=0:
                        if self.last_communication:
                            self.set_state(PyTango.DevState.FAULT)
                        else:
                            self.set_state(PyTango.DevState.UNKNOWN)
                        self.last_failed=time.time()
                        #Between failed communications the retry frequency is reduced
                        if hasattr(self,'threadDict'): 
                            self.threadDict.set_timewait(max(1,self.ErrorTimeWait/1000.))
                        raise e
                    else:
                        fandango.wait(.2)
                        continue
                    
                self.last_communication=time.time()
                if hasattr(self,'threadDict'): 
                    self.threadDict.set_timewait(max(0.01,self.ModbusTimeWait/1000.))
                self.last_exception,self.last_exception_time = '',0
                self.last_failed=0
                if 0.5<(self.last_communication-self.last_try):
                    self.warning('WARNING!:In PyPLC.sendModbusCommand(...): %s: Modbus communication (%s,%s) took %fms!!!'% \
                        (time.ctime(),command,str(arr_argin),1000*(self.last_communication-self.last_try)))
                self.average_read_time = self.average_read_time and (.9*self.average_read_time + .1*(self.last_communication-self.last_try)) or (self.last_communication-self.last_try)
                break #Exit while if there's no exceptions
        finally:
            ## If it is an external command (Synchronous) the threadDict must be stop to execute the external command first.
            if not asynch and hasattr(self,'threadDict'): 
                self.threadDict.start()
        return result
                    
    # -------------------------------------------------------------------------                    
            
    #---- DynamicAttributes State Machine -----------------
    def is_dyn_allowed(self,req_type=None,attr_name=None):
        '''
        Attributes reading will not be allowed until DigitalsREAD has been updated
        '''      
        #@TODO THIS METHOD IS NEVER CALLED!?!?!
        self.debug('In PyPLC.is_dyn_allowed(%s,%s)' % (req_type,attr_name))

        if time.time() < self.time0+10.:
            #A minimum delay is required to guarantee device mappings update
            return False
          
        if attr_name in self.MapDict:
            """ These attributes will be read as ReadMap(attr_name) """
            try:
                if not hasattr(self,'threadDict'): 
                    #self.debug('In PyPLC.is_dyn_allowed(%s): mapped attributes are always allowed'%attr_name)
                    return True
                else:
                    regs = self.MapDict[attr_name].commands
                    if all(fun.isTrue(self.threadDict.get(','.join(str(r) for r in reg))) for reg in regs):
                        return True
                    else:
                        self.warning('In PyPLC.is_dyn_allowed(%s): Values not read yet'%(attr_name))
                        return False
            except Exception,e:
                self.warning('In PyPLC.is_dyn_allowed(%s): Unable to know if available: %s'%(attr_name,e))
                return False
        
        if attr_name not in self.dyn_values:
            self.warning('Dynamic Attribute (%s) does not exists!' % (attr_name))
            raise Exception('Dynamic Attribute (%s) does not exists!' % (attr_name))
            return False
        else: #DynamicAttributes dependent from Mappings will not be allowed if Mappings are empty
            missing = [m for m in self.MapDict if m in self.dyn_values[attr_name].formula and not self.dyn_values[m].value]
            if missing:
                self.info('Dynamic Attribute %s not allowed until %s will be read.' % (attr_name,missing))
                #raise Exception,'Dynamic Attribute %s not allowed until %s will be read.' % (attr_name,missing)
                return False
        return True                
        
    ###########################################################################
    # State Management methods
        
    def State(self):
        """ State redefinition is required to keep independency between 
        attribute configuration (max/min alarms) and the device State """
        #return self.get_state()
        return self._state
    
    def set_state(self,state,push=True):
        self._state = state
        DynamicDS.set_state(self,state,push=push) #PyTango.Device_4Impl.set_state(self,state)
        
    def get_state(self):
        #@Tango6
        #This have been overriden as it seemed not well managed when connecting devices in a same server
        return self._state
    
    def dev_state(self):
        #@Tango7
        #This have been overriden to avoid device servers with states managed by qualities
        return self._state
            
    def check_state(self,set_state=False): pass #Disabling DynamicState management out of always_executed_hook
    def check_status(self,set=False): pass #Disabling DynamicState management out of always_executed_hook
    
    def StateMachine(self,state=None,status=None):
        """
        The State will be ON if there has been a succesful communication in the last MAX_IDLE seconds; 
        STANDBY/UNKNOWN/FAULT depending of previous communication errors
        """
        self.debug('In PyPLC::StateMachine(%s,%s) ...'%(state,status[:80]))
        state,status = state or PyTango.DevState.ON, status or ''
        self.MAX_IDLE = 10*60
        
        if not self.SimulationMode:
            if not self.modbus:
                state = PyTango.DevState.UNKNOWN
                status += 'Modbus Device %s is not defined or not recognized!!!'%(self.Modbus_name)+'\n'+status
            elif not self.last_try:
                state = PyTango.DevState.UNKNOWN
                status += 'No communication has been established with the device'+'\n'+status
            elif self.last_failed:
                state = PyTango.DevState.FAULT
                status += 'Last Communication failed at %s'%time.ctime(self.last_failed)+'\n'+status
            elif self.last_communication < time.time()-self.MAX_IDLE and (self.last_communication or self.last_failed):
                state = PyTango.DevState.FAULT
                status += 'Last Communication was at %s'%time.ctime(self.last_communication)+'\n'+status
            elif not self.last_communication:
                state = PyTango.DevState.INIT
                status += 'Hardware not contacted yet.\n'+status
            else:
                self.maps_failed = []
                if self.MapDict:
                    for k,m in self.MapDict.items():
                        regs = [self.threadDict.get(','.join(map(str,c)),None)
                                 for c in m.commands]
                        if not all(fun.isTrue(r) for r in regs):
                            self.maps_failed.append(k)
                if self.maps_failed and state!=PyTango.DevState.INIT:
                    state = PyTango.DevState.FAULT
                    status += ('Some Mappings are not available:\n\%s'
                        % str(self.maps_failed)
                        +'\n'+status)
                else:
                    state = PyTango.DevState.ON
                    #status += '%s is ON.\n'%self.get_name()+status
                    
        if str(state) not in ('UNKNOWN','FAULT','INIT') and self.last_exception_time<time.time()-600:
            self.last_exception,self.last_exception_time = '',0
        elif self.last_exception:
            status += '\nLast PyPLC Exception was at %s: \n%s' % (time.ctime(self.last_exception_time),str(self.last_exception)[:1000])
        if self.init_errors: 
            status += '\n\nINITIALIZATION ERRORS:\n\t' + '\n\t'.join(self.init_errors)

        self.debug(status)
        return (state,status)
    
    def init_pyplc_lambdas(self,other=None):
        self.PyPLC_LAMBDAS = {
            'Reg':      (lambda _addr: self.Reg(_addr)),
            'InputReg': (lambda _addr: self.InputReg(_addr)),
            'Regs':     (lambda _addr,val: self.Regs([_addr,val])),
            'InputRegs': (lambda _addr,val: self.InputRegs([_addr,val])),
            'InputStatus': (lambda _addr,val: self.InputStatus([_addr,val])),            
            'Regs32':   (lambda _addr,val: self.Regs([_addr,val])),
            'Coil':     (lambda _addr: self.Coil(_addr)),
            'Coils':    (lambda _addr,val: self.Coils([_addr,val])),
            'Flag':     (lambda _addr,val: self.Flag([_addr,val])),
            'IeeeFloat': (lambda *args: self.IeeeFloat(*args)),
            'WriteFloat': (lambda _addr,val: self.WriteFloat([_addr,val])),
            'WriteCoil': (lambda _addr,bit: self.WriteCoil([_addr,bit])),
            'WriteFlag': (lambda _addr,bit,val: 
                              self.WriteFlag([_addr,bit,val])),
            #@TODO: WriteBit Must Be Deprecated!
            'WriteBit': (lambda _addr,bit,val: 
                             self.WriteFlag([_addr,bit,val])), 
            'WriteInt': (lambda _addr,val: self.WriteInt([_addr,val])),
            'WriteLong': (lambda _addr,val: self.WriteLong([_addr,val])),

            'Bit':      (lambda number,val: self.Flag([number,val],HW=False)),            
            'Denary2Binary': (lambda num: self.Denary2Binary(num)),
            'Binary2Denary': (lambda bin: int(str(bin),2)),        
            
            'ReadMap': (lambda *args: self.ReadMap(*args)),
            'Dec2Bits': (lambda dec,n=16: self.Dec2Bits(dec,n)),
            'Dec2Bin': (lambda num: self.Denary2Binary(num)),
            'Bin2Dec': (lambda bin: int(str(bin),2)),              
            }
        if other: 
            self.PyPLC_LAMBDAS.update(other)
        return self.PyPLC_LAMBDAS
            
    def init_parent_classes(self,cl,name):
        self.call__init__(DynamicDS,cl,name,globals(),
            _locals = self.init_pyplc_lambdas(), useDynStates=True)
        self.call__init__(PyTango.Device_4Impl,cl,name)
        
    def exception_hook(self,fname=None,args=None,e=None):
        self.last_exception = traceback.format_exc()
        self.last_exception_time= time.time()        
        fname = str(fname or type(self))
        e = e or Exception(str(e))
        args = str(args or [])
        self.warning('Exception in %s(%s):\n%s'
                     %(fname,args,self.last_exception))

        if isinstance(e,PyTango.DevFailed):
            PyTango.Except.throw_exception(str(e.args[0]['reason']),
                str(e.args[0]['desc']),fname+':'+str(e.args[0]['origin']))
        else:
            PyTango.Except.throw_exception(str(e),"Something wrong!",fname)        
            
                
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        self.StaticAttributes = []
        self.init_parent_classes(cl,name)     
        PyPLC.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        try:
            print('-'*80)
            print("[Device delete_device method] for %s"%self.get_name())
            #self.set_state(PyTango.DevState.INIT)
            if hasattr(self,'threadDict'):
                self.threadDict.stop()
            #Device crashes to core even without threadDict!!
            
            #Waiting here provided no improvement
            try: 
                self.modbusLock.release()
            except: 
                pass          
            del self.modbus
            fandango.wait(1.)
            print('threadDict.alive(): %s' % self.threadDict.alive())
            DynamicDS.delete_device(self)
        except: 
            traceback.print_exc()
        print('-'*80)

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self,check_polled=True,get_properties=True):
        '''
        :param check_polled: allows sub-classes to customize polled attributes verification
        :param get_properties: avoids redundant property reloading
        '''        
        print "In ", self.get_name(), "::init_device()"
        self.init_errors = []
        self.set_state(PyTango.DevState.UNKNOWN)
        if get_properties: self.get_DynDS_properties()
        self.setLogLevel(self.LogLevel)
        
        #The STATE_MACHINE_PERIOD will control how frequently 
        #PyPLC.StateMachine will be called (within always_executed_hook)
        #used to control frequency of polling status log
        self.PollingCycle = max(
            (self.KeepTime,self.get_polled_attrs().get('state',1000.))) 
        
        self.STATE_MACHINE_PERIOD = self.PollingCycle/1e3

        # INITIALIZING MODBUS CONNNECTION
        # -----------------------------------------------------------
        self.info('Initializing Modbus connection')
        self.modbus = None
        self.modbusLock = getattr(self,'modbusLock',None) or threading.Lock()
        prop = PyTango.Database().get_device_property(self.get_name(),['Modbus_name'])
        self.Modbus_name = toList(prop.get('Modbus_name',['']))[0]
        self.last_try,self.last_failed,self.last_communication,self.average_read_time = 0,0,0,0
        self.last_exception,self.last_exception_time,self.last_state_machine = '',0,0

        if len(self.Modbus_name)>0:
            try:
                self.modbus = PyTango.DeviceProxy(self.Modbus_name)
                try: self.modbus.set_timeout_millis(1000)
                except: self.warning('Unable to set modbus timeout to 1000')
                try:
                    self.modbus.ping()
                    self.set_state(PyTango.DevState.INIT)
                except Exception,e:
                    msg = "Modbus Device %s is not working!\n%s"%(self.Modbus_name,str(e))
                    self.warning(msg),self.set_status(msg)
                    self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
            except Exception,e:
                self.modbus = None
                msg = "Modbus Device %s is not recognized!!!\n%s"%(self.Modbus_name,str(e))
                self.warning(msg),self.set_status(msg)
                self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
        else:
            msg = "Modbus Device %s is not defined!!!"
            self.error(msg),self.set_status(msg)
        
        # PARSING MAPPING PROPERTY
        # ------------------------------------------------- 
        self.parseMappingProperty(update=True)
        if self.MapDict is not None: 
            for v in self.MapDict.values():
                v.plc_obj = self        
            #Parsing ModbusCacheConfig Property
            if self.modbus and hasattr(self,'ModbusCacheConfig') and self.ModbusCacheConfig:
                self.SetModbusCacheConfig()
            else: 
                self.warning("ModbusCacheConfig Property has not been defined")                
            if check_polled: 
                self.check_polled_attributes(new_attr=dict.fromkeys(self.MapDict.keys(),3000))
            self.initThreadDict()
        
        self.info('PyPLC Ready to accept request ...')
        
    def updateDynamicAttributes(self):
        """Forces dynamic attributes update from properties.
        @warning : It will DELETE all attributes that does not appear in DynamicAttributes property or StaticAttributes list!
        """
        xmap = self.Mapping
        DynamicDS.updateDynamicAttributes(self)
        if self.Mapping!=xmap: self.parseMappingProperty(update=True)
        #The STATE_MACHINE_PERIOD will control how frequently PyPLC.StateMachine will be called (within always_executed_hook)
        self.PollingCycle = max((self.KeepTime,self.get_polled_attrs().get('state',1000.))) #used to control frequency of polling status log
        self.STATE_MACHINE_PERIOD = self.PollingCycle/1e3

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        #print "In ", self.get_name(), "::always_excuted_hook() at ",time.time()
        try:
            self.debug("In "+self.get_name()+"::always_executed_hook()"+"<"*40)
            now = time.time()
                
            prev = self.get_state()

            if not getattr(self.threadDict,'_Thread',None):
                self.warning('Starting PyPLC.threadDict ...')
                self.threadDict.start()

            
            #State is evaluated just once per second (KeepTime property value)
            if now > (self.last_state_machine+self.STATE_MACHINE_PERIOD):
                
                self.last_state_machine = now
                #self.set_state(PyTango.DevState.ON),self.set_status('') #Default PyPLC State
                DynamicDS.always_executed_hook(self) #<= DynamicStates disabled here
                state0,status0 = self.get_state(),self.get_status() #For Logging purposes
                if self.dyn_states: 
                    state0 = DynamicDS.check_state(self,set_state=False,current=state0)
                    self.debug('DynamicStates: %s(%s)'%(type(state0),state0))
                    
                if self.DynamicStatus: 
                    status0 = DynamicDS.check_status(self)
                    
                state,status = self.StateMachine(state0,'')#,status0) #Communication errors override DynamicStates machine
                if state!=state0: self.debug('StateMachine: %s(%s)'%(type(state),state))
                txt = 'Device is in %s State'%str(state)
                self.set_status(txt+'\n'+status if txt not in status else status)
                
                if prev!=state:
                    comment = '%s.State changed: %s => %s => %s'%(self.get_name(),str(prev),str(state0),str(state))
                    try: self.SaveSnapFile(comment=comment)
                    except: pass
                    self.info( '*'*80)
                    self.info(comment)
                    self.info( '*'*80)
                    
                self.set_state(state,push=True) #it must not be in the if!, Events will be pushed here
                self.debug('StateMachine took %d ms' % (1000*(time.time()-now)))
        
        except Exception,e:
            self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
            self.error('Exception in always_executed_hook: %s'%str(e))
            print '*'*80 + '\n' +self.last_exception + '\n' + '*'*80


#==================================================================
#
#    PyPLC read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        read_attrs = DynamicDS.read_attr_hardware(self,data)
        self.debug("read_attr_hardware([%d]=%s)"%(len(data),str(read_attrs)[:80]))
        
    def read_AverageModbusCycle(self, attr=None):
        v = 0.0
        if getattr(self,'threadDict',None):
            v = self.threadDict.cycle_average
        attr.set_value(float(v))
        

#==================================================================
#
#    PyPLC command methods
#
#==================================================================

#------------------------------------------------------------------
#    Reg command:
#
#    Description: 
#    argin:  DevLong    Modbus Address
#    argout: DevLong    Value Read/Written
#------------------------------------------------------------------
    
    def Reg(self, argin):
        self.debug("In "+self.get_name()+"::Reg()")
        #    Add your own code here
        
        # The DefaultReadCommand Modbus Command uses Arrays as both Argument In and Out
        arr_argin=[argin,1]
        argout = self.sendModbusCommand(self.DefaultReadCommand,arr_argin)
        return argout[0]


#------------------------------------------------------------------
#    HoldingReg command:
#
#    Description: 
#    argin:  DevLong    Modbus Address
#    argout: DevLong    Value Read/Written
#------------------------------------------------------------------
    
    def HoldingReg(self, argin):
        self.debug("In "+self.get_name()+"::HoldingReg()")
        #    Add your own code here
        if True: #try:
            # The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
            arr_argin=[argin,1]
            argout = self.sendModbusCommand("ReadHoldingRegisters",arr_argin)
            return argout[0]


#------------------------------------------------------------------
#    InputReg command:
#
#    Description: 
#    argin:  DevLong    Modbus Address
#    argout: DevLong    Value Read/Written
#------------------------------------------------------------------
    
    def InputReg(self, argin):
        self.debug("In "+self.get_name()+"::InputReg()")
        #    Add your own code here
        # The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        arr_argin=[argin,1]
        argout = self.sendModbusCommand("ReadInputRegisters",arr_argin)
        return argout[0]


#------------------------------------------------------------------
#    @mniegowski 
#   
#    IeeeFloat command:
#
#    Description
#    argin: Modbus Address OR two int32 values to convert
#    argout: Float value of the combined two next Registers
#------------------------------------------------------------------
    
    def IeeeFloat(self,*argin):
        """
        This method can be called with three diferent types of arguments:
        
            - integer address: It will read an IeeeFloat from 2 consecutive
                Modbus Registers
                
            - an array of 2 integers: Skip modbus and call Ints2Float
            
            - an array and an index: get first 2 integers from the array index
        
        """
        self.debug("In "+self.get_name()+"::IeeeFloat("+str(argin)+")")
        
        try:
            #Polimorphism (Tango commands will pass an array with all args)
            if len(argin)==1: argin = argin[0]
            
            #Check for single Modbus address
            if not fun.isSequence(argin):
                argin = int(argin)
            elif len(argin)==1:
                argin = int(argin[0])
                
            #Get data from Modbus address via ReadHolginRegisters
            if isinstance(argin,int):
                arr_argin = [argin,2]
                cmd = "ReadHoldingRegisters"
                self.info('IeeeFloat(%s(%s))'%(cmd,arr_argin))
                argin = self.sendModbusCommand(cmd,arr_argin)

            #If not using Modbus, extract raw data from arguments
            elif fun.isSequence(argin[0]):
                i = int(argin[1])
                argin = argin[0][i],argin[0][i+1]
            else:
                argin = argin[0],argin[1]
                    
            return self.Ints2Float(argin)
            
        except Exception,e:
            self.exception_hook(inspect.currentframe().f_code.co_name,argin,e)

#------------------------------------------------------------------
#    @mniegowski 
#   
#    Coil command:
#
#    Description
#    argin: Coil Address
#    argout: Coil Status 
#------------------------------------------------------------------
    
    def Coil(self, arr_argin):
        self.debug("In %s::Coil()"%self.get_name())
        #    Add your own code here

        argout = self.sendModbusCommand("ReadCoilStatus",arr_argin)
        return argout[0]

#------------------------------------------------------------------
#    @mniegowski 
#   
#    Flag command:
#
#    Description
#    argin: Modbus Address, Number of corresponding bit
#    argout: Boolean Value
#------------------------------------------------------------------

    def Flag(self,argin,HW=True):
        """ Returns the value of the given bit within a 16bits register
        :param HW:  If True, a register will be read from the given address. 
                    If False the address will be used as register value
        :param argin[0]: The address/value of the int register
        :param argin[1]: the bit to be returned
        """
        self.debug("In %s.Flag(%s)"%(self.get_name(),argin))
        _addr = int(argin[0])# if argin[0] is not None else 0)
        n = int(argin[1])# if argin[1] is not None else 0)
        
        if 0<=n<16:
            reg = int(self.sendModbusCommand("ReadHoldingRegisters",[int(_addr),1])) if HW else _addr
            tval = self.Denary2Binary(reg)
            argout = int(tval[15-n]) 
            return argout
        else:
            PyTango.Except.throw_exception("PyPLC_IndexOutOfRange","Error:Selected Bit must be between 0 and 15",inspect.currentframe().f_code.co_name)

#------------------------------------------------------------------
#    Bit command:
#
#    Description
#    argin: Get a bit from an int (It is not accessing Hardware at all!)
#    argout: Boolean Value
#------------------------------------------------------------------
    
    def Bit(self,argin):
        return self.Flag(argin,HW=False)

#------------------------------------------------------------------
#   
#    Regs command:
#
#    Description
#    argin: Modbus Address, Number of Registers
#    argout:Read Values Array
#------------------------------------------------------------------

    def Regs(self,arr_argin,asynch=False):
        """ 
        The DefaultReadCommand Modbus Command uses Arrays as both Argument In and Out
        :param arr_argin: [_addr,n]
        """
        if len(arr_argin)==3 and not isNumber(arr_argin[2]):
            comm,arr_argin = arr_argin[2],arr_argin[:2]
        else:
            comm = self.DefaultReadCommand
            
        argout = self.sendModbusCommand(comm,arr_argin,asynch=asynch)
        return argout
    
#------------------------------------------------------------------
#   
#    HoldingRegs command:
#
#    Description
#    argin: Modbus Address, Number of Registers
#    argout:Read Values Array
#------------------------------------------------------------------

    def HoldingRegs(self,arr_argin,asynch=False):
        """
        The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        :param arr_argin: [_addr,n]
        """
        argout = self.sendModbusCommand("ReadHoldingRegisters",arr_argin,asynch=asynch)
        return argout    
        
#------------------------------------------------------------------
#   
#    InputRegs command:
#
#    Description
#    argin: Modbus Address, Number of Registers
#    argout:Read Values Array
#------------------------------------------------------------------

    def InputRegs(self,arr_argin):
        """
        The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        :param arr_argin: [_addr,n]
        """
        argout = self.sendModbusCommand("ReadInputRegisters",arr_argin)
        return argout        


#------------------------------------------------------------------
#   
#    InputStatus command:
#
#    Description
#    argin: Modbus Address, Number of Registers
#    argout:Read Values Array
#------------------------------------------------------------------

    def InputStatus(self,arr_argin):
        """
        The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        :param arr_argin: [_addr,n]
        """
        argout = self.sendModbusCommand("ReadInputStatus",arr_argin)
        return argout 


#------------------------------------------------------------------
#    @mniegowski 
#   
#    Regs command:
#
#    Description
#    argin: Modbus Address, Number of Registers * 2 
#    argout:32 bit long values
#------------------------------------------------------------------        
            
    def Regs32(self,argin):
        n = int(argin[1])*2
        _addr = argin[0]

        # The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        arr_argin=[_addr,n]
        vals = self.sendModbusCommand("ReadHoldingRegisters",arr_argin)
        argout=[0]*(n/2)
        for i in range (0,n,2):
            j = i/2
            argout[j] = 32768*int(vals[i]) + int(vals[i+1])
        return argout

#------------------------------------------------------------------
#    @mniegowski 
#   
#    Coils command:
#
#    Description
#    argin: Coil Address, Number of Coils
#    argout:Read Values Array
#------------------------------------------------------------------

    def Coils(self,arr_argin):
        argout = self.sendModbusCommand("ReadMultipleCoilsStatus",arr_argin)
        return argout



#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteInt command:
#
#    Description
#    argin: Modbus Address, Int value to be Inserted 
#    argout: OK
#------------------------------------------------------------------

    def WriteInt(self,arr_argin):
        self.debug("In WriteInt()")
        if True: #try:
            self.sendModbusCommand("PresetSingleRegister",arr_argin)
            return arr_argin[-1]

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteLong command:
#
#    Description
#    argin: Modbus Address, Int value to be Inserted 
#    argout: OK
#------------------------------------------------------------------
    
    def WriteLong(self,argin):
        self.debug("In WriteLong()")
        n = int(argin[1])
        _addr = argin[0]
        if True: #try:
            hw = int(n/32768)
            lw = int(n%32768)
            arr_argin = [_addr,2,hw,lw]
            self.sendModbusCommand("PresetMultipleRegisters",arr_argin)
            return argin[-1]

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteFloat command:
#
#    Description
#    argin: Modbus Address, and Float value to store; NOTE Remember that the value will be stored in 
#           the given and also the next register as for storing float values 32-bits are needed
#    argout: For now both inserted Values 
#------------------------------------------------------------------

            
    def WriteFloat(self,argin):        
        _addr = int(argin[0])
        v = eval(str(argin[1]))
        self.debug("In WriteFloat(%s)"%str(argin))
        try:
            p = struct.pack("!f", v)
            i = struct.unpack("!I", p)
            s = "%08x" % int(i[0])
            hw = s[:4]
            lw = s[4:]
            high = int(hw,16)
            low = int(lw,16)
            #print high, " ", low
            temph = self.Denary2Binary(high)
            templ = self.Denary2Binary(low)
            if int(temph[0]) == 1:
                bla = self.negBinary(temph)
                high = int(bla,2)
                high = (-1)*high
            if int(templ[0]) == 1:
                bla = self.negBinary(templ)
                low = int(bla,2)
                low = (-1)*low            
            arr_argin = [_addr,2,low,high]
            self.sendModbusCommand("PresetMultipleRegisters",arr_argin)
            argout =  'LW:  %d  ,  HW:  %d' % (low,high)
            #return argout
            return argin[-1]
        except PyTango.DevFailed, e:
            self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
            self.warning("In WriteFloat(%s)"%str(argin)+":"+self.last_exception)
            PyTango.Except.throw_exception(str(e.args[0]['reason']),str(e.args[0]['desc']),inspect.currentframe().f_code.co_name+':'+str(e.args[0]['origin']))
        except Exception,e:
            self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
            self.warning("In WriteFloat(%s)"%str(argin)+":"+self.last_exception)
            PyTango.Except.throw_exception(str(e),"Something wrong!",inspect.currentframe().f_code.co_name)    

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteCoil command:
#
#    Description
#    argin: Coil Address, Value to be Inserted 0/1
#    argout: OK
#------------------------------------------------------------------

    def WriteCoil(self, arr_argin):
        self.debug("In WriteCoil()")
        if (arr_argin[1]==0 or arr_argin[1]==1):
            self.sendModbusCommand("ForceSingleCoil",arr_argin)
            return arr_argin[-1]
        else: 
            PyTango.Except.throw_exception("PyPLC_IndexOutOfRange","Value must be 0 or 1",inspect.currentframe().f_code.co_name)

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteFlag command:
#
#    Description
#    argin: Modbus Address, Number of corresponding bit, Value to be inserted
#    argout: "OK"
#------------------------------------------------------------------
    @Catched
    def WriteFlag(self,argin):
        self.info('In PyPLC(%s).WriteFlag(%s)'%(self.get_name(),argin))
        #Type casting needed to prevent exceptions (sigh!)
        addr,n,flag = [int(i) for i in argin[:3]]
        reg = None
        now = time.time()
        if 0<=n<16 and 0<=flag<=1:
            #Checking if address is cached
            for j,m in enumerate(self.MapDict.values()):
                if m and m.has_address(addr) and now<(m.time+len(self.threadDict.keys())*2*self.ModbusTimeWait):#(self.KeepTime*1e-3)):
                    reg = m.get_address(addr)
            #If address not cached:
            if reg is None:
                reg = int(self.sendModbusCommand("ReadHoldingRegisters",[addr,1])[0])
            flag = str(flag)
            binval = self.Denary2Binary(reg)
            argout = binval[:15-n] + flag + binval[16-n:]
            ins = self.Binary2Denary(argout)
            self.info("Writing into the %d register: %s = %s"%(addr,argout,ins))
            self.sendModbusCommand("PresetSingleRegister",[addr,ins])
            return argin[-1]
        else:
            PyTango.Except.throw_exception("PyPLC_IndexOutOfRange","Wrong Input",inspect.currentframe().f_code.co_name)        

#------------------------------------------------------------------
#    srubio@cells.es 
#   
#    SetModbusCacheConfig command:
#
#    Description
#    argin: 
#    argout: 
#------------------------------------------------------------------

    def SetModbusCacheConfig(self):
        '''
        This method should inspect the ranges declared in Mapping Property and setup 
        the Modbus CacheConfig Property to read this addresses in a period shorter than the polling period.
        '''
        if self.modbus and self.MapDict :
            try:
                mcc = self.ModbusCacheConfig if hasattr(self,'ModbusCacheConfig') and self.ModbusCacheConfig else "1000"
                self.debug("ModbusCacheConfig: %s"%mcc)
                if not isinstance(mcc,str) or not any(c in mcc.lower() for c in ['no','false']):
                    self.info('Configuring %s CacheConfig and ConfigSleep.' % self.Modbus_name)
                    comms,cache_config = [],[]
                    for k,vmap in self.MapDict.items():
                        comms.extend(vmap.commands)
                    if comms:
                        self.info('Updating %s properties. Commands in Mapping are: %s' % (self.Modbus_name,comms))
                        db = PyTango.Database()
                        new_props,old_props = {},db.get_device_property(self.Modbus_name,['CacheConfig','CacheSleep','_UsedBy'])
                        old_comms,i,n = [],0,len(old_props['CacheConfig'])
                        while i<n:
                            if i<n-1:#0%3==1 and i<n-1:
                                val1,val2 = tuple(old_props['CacheConfig'][i:i+2])
                                if val1.isdigit() and val2.isdigit():
                                    values = (int(val1),int(val2),)
                                    if values in old_comms: 
                                        self.warning('Mapping %s is repeated in ModbusCacheConfig!'%str(values))
                                    else:
                                        cache_config.extend(['ReadHoldingRegisters',str(values[0]),str(values[1])])
                                        old_comms.append(values)
                                        self.debug('Regs(%d,%d) Read from %s Cache Config' % (values[0],values[1],self.Modbus_name))
                                #else: self.warning('Invalid values in Modbus(%s) Cache Config' % self.Modbus_name)
                            i+=1
                        self.debug('Mapping obtained from %s Cache Config: %s' % (self.Modbus_name,old_comms))
                        
                        for comm in sorted(comms):
                            if comm not in old_comms:
                                cache_config.extend(['ReadHoldingRegisters',str(comm[0]),str(comm[1])])
                                self.debug('Regs(%s,%s) added to %s Cache Config' % (comm[0],comm[1],self.Modbus_name))
                            else: 
                                self.debug('Regs(%s,%s) already in %s Cache Config' % (comm[0],comm[1],self.Modbus_name))
                        
                        period = int(mcc) if str(mcc).isdigit() \
                            else (old_props['CacheSleep'][0] if old_props['CacheSleep'] else 1000)
                        used = old_props['_UsedBy'] + [self.get_name()] if self.get_name() not in old_props['_UsedBy'] else []
                        db.put_device_property(self.Modbus_name,{'CacheConfig':cache_config,'CacheSleep':[period],'_UsedBy':used})
                        
                        if len(cache_config)!=len(old_props['CacheConfig']): 
                            #THIS IS HARMFUL!!! MODBUS DEVICE DOES NOT CLOSE CONNECTIONS IN init();
                            #WHEN EXECUTED 3 TIMES IT HUNGS THE PLC!!!
                            #self.info('Restarting Modbus device to update CacheConfig ...')
                            #self.Reconnect()
                            self.info('Modbus Device Server must be fully restarted to update CacheConfig ...')
                        
                        return "DONE\n%s.CacheConfig:\n%s\n\nModbus SERVER must be FULL restarted now." % \
                            (self.Modbus_name,'\n'.join(cache_config))
                    else: 
                        self.info('NO Modbus Commands in Mapping property.')
                        return "NOTHING TO DO"
                else: 
                    self.info('NOT Configuring %s CacheConfig and ConfigSleep.' % self.Modbus_name)
                    return "NOT ALLOWED"
            except Exception,e:
                self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
                self.error("Exception in PyPLC.SetModbusCacheConfig: %s" % self.last_exception)
                return "EXCEPTION: %s" % self.last_exception
        return "MODBUS NOT INITIALIZED"

#------------------------------------------------------------------
#    srubio@cells.es 
#   
#    Reconnect command:
#
#    Description
#    argin: 
#    argout: 
#------------------------------------------------------------------

    def Reconnect(self):
        '''
        THIS IS HARMFUL!!! MODBUS DEVICE DOES NOT CLOSE CONNECTIONS IN init();
        WHEN EXECUTED 3 TIMES IT HUNGS THE PLC!!!
        This Command executes Init() and State() calls in the Modbus Device.
        '''
        raise Exception, \
            "MODBUS.init() IS HARMFUL!!! MODBUS DEVICE DOES NOT CLOSE CONNECTIONS IN init();"+\
            "\nWHEN EXECUTED SEVERAL TIMES IT MAY HUNG THE PLC!!!"+\
            "\n RESTART MODBUS USING ASTOR INSTEAD"


#------------------------------------------------------------------
#    srubio@cells.es 
#   
#    SaveSnapFile command:
#
#    Description
#    argin: filename
#    argout: filename
#------------------------------------------------------------------

    def SaveSnapFile(self,argin='',comment=''):
        """
        This method saves the content of Mappings in filename.
        If no filename is given the SnapFile property is used.
        Filenames would be like PyPLC_$DEVICE_$DATE.stamp
        """
        try:
            filename = (argin.strip() or self.SnapFile)
            if filename.strip('#').lower() not in ('no','none','false',''):
                
                date = fandango.time2str().replace('-','').replace(':','').replace(' ','')
                device = self.get_name().replace('/','_').replace('-','_').upper()
                filename = filename.replace('$DEVICE',device).replace('$DATE',date)
                self.info('SaveSnapFile(%s): Saving attribute values to %s'%(
                  comment,filename))
                data = '#'+fandango.time2str()+':'+str(comment)+'\n\n'
                data+=('%s = {\n\n'%device)
                data+=('"Name" : "%s",\n\n'%str(self.get_name()))
                data+=('"State" : "%s",\n\n'%str(self.get_state()))
                data+=('"Status" : """%s""",\n\n'%str(self.get_status()))
                for k,v in sorted(self.dyn_values.items()):
                    vv = fandango.str2type(v.value,sep_exp='')
                    if fandango.isString(vv): vv = vv.replace('\n',';')
                    value = {'value':vv,'date':v.date,'quality':str(v.quality)}
                    value['date'] = v.date
                    value['quality'] = str(v.quality)
                    value['type'] = str(getattr(v.type,'labels',[v.type])[0])
                    data+=('"%s" : \n%s\n,\n\n'%(k,repr(value)))
                data+=('}')
                if ':' in filename:
                    try:
                      fandango.device.FolderAPI().save(filename,filename,data,asynch=True)
                    except:
                      self.warning(traceback.format_exc())
                else:
                    f = open(filename,'w')
                    f.write(data)
                    f.close()
            return filename
        except:
            self.warning('Exception at SaveSnapFile(%s):\n%s'%(filename,traceback.format_exc()))
            if argin.strip(): raise

#==================================================================
#
#    PyPLCClass class definition
#
#==================================================================
class PyPLCClass(PyTango.PyDeviceClass):
    
    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'Modbus_name':
            [PyTango.DevString,
            "The name of the Modbus Tango Device used to communicate with the PLC.\nAll the information related to the communication must be specified using the \nModbus device properties.",
            [] ],
        'LogLevel':
            [PyTango.DevString,
            "Default console output configuration.",
            ["INFO"] ],
        'MaxModbusQuerySize':
            [PyTango.DevLong,
            "Maximum amount of data that can be asked in a single Modbus request.",
            [120] ],
        'Mapping':
            [PyTango.DevVarStringArray,
            "Arrays to be permanently updated, declared like : ARRAY:0,+120  #(VarName:StartAddress,+ArrayLength)",
            [] ], 
        'ModbusCacheConfig':
            [PyTango.DevLong,
            "If ModbusCacheConfig>0 then it will update CacheConfig and CacheSleep properties of the Modbus device using Mapping values.",
            [0] ],
        'ModbusTimeWait':
            [PyTango.DevLong,
            "Number of milliseconds to wait between asynchronous Modbus calls",
            [50] ],
        'DefaultReadCommand':
            [PyTango.DevString,
            "Default read command executed by Reg and Regs commands",
            ["ReadHoldingRegisters"] ],            
        'AddressOffset':
            [PyTango.DevLong,
            "Integer offset added to Addresses in every Modbus command call.",
            [0] ],        
        'ErrorTimeWait':
            [PyTango.DevLong,
            "Number of milliseconds between retries after a Modbus error",
            [10000] ],
        'SimulationMode':
            [PyTango.DevBoolean,
            "If True then modbus commands are ignored and only virtual attributes are evaluated.",
            [False] ],
        #Properties from DynamicDS class, default values tuned
        'DynamicAttributes':
            [PyTango.DevVarStringArray,
            "Attributes and formulas to create for this device.\nThis Tango Attributes will be generated dynamically using this syntax:\nT3=int(Reg(7007)/10.)\nThe commands Coil; Flag; Reg and fReg will allow to declare \nDigital; Bit; Integer and Float variables respectively.",
            [] ],
        'DynamicStates':
            [PyTango.DevVarStringArray,
            "This property will allow to declare new States dinamically based on\ndynamic attributes changes. The function Attr will allow to use the\nvalue of attributes in formulas.\n\nALARM=Attr(T1)>70\nOK=1",
            [] ],
        'DynamicQualities':
            [PyTango.DevVarStringArray,
            "This property will allow to declare formulas for Attribute Qualities.",
            [] ],
        'DynamicStatus':
            [PyTango.DevVarStringArray,
            "Each line generated by this property code will be added to status",
            [] ],
        'KeepAttributes':
            [PyTango.DevVarStringArray,
            "This property can be used to store the values of only needed attributes; values are 'yes', 'no' or a list of attribute names",
            ['yes'] ],
        'KeepTime':
            [PyTango.DevDouble,
            "The kept value will be returned if a kept value is re-asked within this milliseconds time (Cache).",
            [ 500 ] ],
        'CheckDependencies':
            [PyTango.DevBoolean,
            "This property manages if dependencies between attributes are used to check readability.",
            [True] ],
        'UseEvents':
            [PyTango.DevVarStringArray,
            "Value of this property will be yes/true,no/false or a list of attributes that will trigger push_event (if configured from jive)",
            ['true'] ],
        'LogLevel':
            [PyTango.DevString,
            "This property selects the log level (DEBUG/INFO/WARNING/ERROR)",
            ['INFO'] ],
        'SnapFile':
            [PyTango.DevString,
            "File were all attribute values will be saved on device state change, e.g. /tmp/PyPLC_$DEVICE_$DATE.stamp",
            [''] ],
        }


    #    Command definitions
    cmd_list = {
        'Reg':
            [[PyTango.DevShort, "Modbus Address"],
            [PyTango.DevShort, "Value of the register"]],
        'HoldingReg':
            [[PyTango.DevShort, "Modbus Address"],
            [PyTango.DevShort, "Value of the register"]],                
        'InputReg':
            [[PyTango.DevShort, "Modbus Address"],
            [PyTango.DevShort, "Value of the register"]],            
        'IeeeFloat':
            #[[PyTango.DevShort, "Modbus Address"],
            [[PyTango.DevVarLongArray, "Modbus Address OR two int32 to convert"],
            [PyTango.DevDouble, "Float Value obtained"]],
        'Coil':
            [[PyTango.DevShort, "Coil Address"],
            [PyTango.DevShort, "Status of Coil"]],
        'Flag':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Flag"],
            [PyTango.DevShort, "Value of the flag in the given Address"]],
        'Bit':
            [[PyTango.DevVarShortArray, "Bit(int,bit): Get a bit from an int (It is not accessing Hardware at all!)"],
            [PyTango.DevShort, "Bit(int,bit): Get a bit from an int (It is not accessing Hardware at all!)"]],            
        'Regs':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarShortArray, "Spectrum of read Values"]],
        'HoldingRegs':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarShortArray, "Spectrum of read Values"]],             
        'InputRegs':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarShortArray, "Spectrum of read Values"]],            
        'InputStatus':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarShortArray, "Spectrum of read Values"]], 
        'Regs32':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarLongArray, "Spectrum of read Values"]],
        'Coils':
            [[PyTango.DevVarShortArray, "Coil Address, Nb of coils"],
            [PyTango.DevVarShortArray, "Status of Coils"]],
        'WriteInt':
            [[PyTango.DevVarShortArray, "Modbus Address, Int Value"],
            [PyTango.DevShort, "Written value"]],
        'WriteLong':
            [[PyTango.DevVarLongArray, "Modbus Address, Long Value"],
            [PyTango.DevLong, "Written value"]],
        'WriteFloat':
            [[PyTango.DevVarStringArray, "Modbus Address, Float Value to be written"],
            [PyTango.DevString, "Written value"]],
        'WriteCoil':
            [[PyTango.DevVarShortArray, "Coil Address, Value - 0/1"],
            [PyTango.DevShort, "Written value"]],
        'WriteFlag':
            [[PyTango.DevVarShortArray, "Modbus Address, Bit to Modify, New Bit Value 0/1"],
            [PyTango.DevShort, "Written value"]],

        'updateDynamicAttributes':
            [[PyTango.DevVoid, "It will DELETE all attributes that does not appear in DynamicAttributes property or StaticAttributes list!"],
            [PyTango.DevVoid, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'evaluateFormula':
            [[PyTango.DevString, "formula to evaluate"],
            [PyTango.DevString, "result"],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'isLocked':
            [[PyTango.DevVoid, ""],
            [PyTango.DevBoolean, "lock status"],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'Lock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
         'Unlock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'setLogLevel':
            [[PyTango.DevString, "DEBUG,INFO,WARNING,ERROR"],
            [PyTango.DevVoid, "Modifies the console output of the device server."],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
       'SetModbusCacheConfig':
            [[PyTango.DevVoid, "This command will update the CacheConfig and CacheSleep properties of the Modbus device."],
            [PyTango.DevString, "This command will update the CacheConfig and CacheSleep properties of the Modbus device."],
            {
                'Display level':PyTango.DispLevel.EXPERT,
            } ],
       'Reconnect':
            [[PyTango.DevVoid, "This Command executes Init() and State() calls in the Modbus Device."],
            [PyTango.DevString, "This Command executes Init() and State() calls in the Modbus Device."],
            {
                'Display level':PyTango.DispLevel.EXPERT,
            } ],
        'SaveSnapFile':
            [[PyTango.DevString, "Save attribute values to file like PyPLC_$DEVICE_$DATE.stamp"],
            [PyTango.DevString, "Save attribute values to file like PyPLC_$DEVICE_$DATE.stamp"],
            {
                'Display level':PyTango.DispLevel.EXPERT,
            } ],
        }


    #    Attribute definitions
    attr_list = {
        'AverageModbusCycle':
           [[PyTango.DevDouble,
           PyTango.SCALAR,
           PyTango.READ]],            
        }


#------------------------------------------------------------------
#    PyPLCClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.PyDeviceClass.__init__(self, name)
        self.set_type(name);
        print "In PyPLCClass  constructor"


#==================================================================
#
#    PyPLC class main method
#
#==================================================================
def main():
    try:
        py = ('PyUtil' in dir(PyTango) and PyTango.PyUtil or PyTango.Util)(sys.argv)
        from fandango.interface import FullTangoInheritance
        PyPLC,PyPLCClass = FullTangoInheritance('PyPLC',PyPLC,PyPLCClass,DynamicDS,DynamicDSClass,Exclude=['Lock','Unlock','isLocked'],ForceDevImpl=True)
        #srubio: it has been added for backward compatibility
        PyPLC.WriteBit,PyPLCClass.cmd_list['WriteBit']=PyPLC.WriteFlag,[[PyTango.DevVarShortArray, "DEPRECATED, Use WriteFlag instead"], [PyTango.DevVoid, "DEPRECATED, Use WriteFlag instead"]]

        if 'Modbus' in  PyTango.Database().get_device_class_list('PyPLC/%s'%sys.argv[1]):
            try: py.add_Cpp_TgClass('Modbus','Modbus')
            except: print 'Modbus Class not loaded'
        py.add_TgClass(PyPLCClass,PyPLC,'PyPLC')
        
        U = PyTango.Util.instance()
        fandango.dynamic.CreateDynamicCommands(PyPLC,PyPLCClass)
        U.server_init()
        U.server_run()
        print('waiting ...')
        fandango.wait(3.)

    except PyTango.DevFailed,e:
        print '__main__ -------> Received a DevFailed exception:',e
        traceback.print_exc()
    except Exception,e:
        print '__main__ -------> An unforeseen exception occured....',e
        traceback.print_exc()


if __name__ == '__main__':
    main()

else:
    from fandango.interface import FullTangoInheritance
    PyPLC,PyPLCClass = FullTangoInheritance('PyPLC',PyPLC,PyPLCClass,DynamicDS,DynamicDSClass,Exclude=['Lock','Unlock','isLocked'],ForceDevImpl=True)
    #srubio: it has been added for backward compatibility
    PyPLC.WriteBit,PyPLCClass.cmd_list['WriteBit']=PyPLC.WriteFlag,[[PyTango.DevVarShortArray, "DEPRECATED, Use WriteFlag instead"], [PyTango.DevVoid, "DEPRECATED, Use WriteFlag instead"]]
