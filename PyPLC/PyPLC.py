#       "$Name:  $";
#       "$Header: /cvsroot/tango-ds/InputOutput/PyPLC/PyPLC.py,v 1.15 2012/03/20 09:09:30 sergi_rubio Exp $";
#=============================================================================
#
# file :        PyPLC.py
#
# description : Python source for the PyPLC and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                PyPLC are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  DynamicDS and ModbusCommunications: Sergi Rubio i Manrique, srubio@cells.es; 
#            Commands and DataType management: Maciej Niegowski, mniegowski@cells.es $
#
# $Revision: 1.15 $
#
# $Log: PyPLC.py,v $
# Revision 1.15  2012/03/20 09:09:30  sergi_rubio
# using DynamicDS.set_state to push events
# State management modified in PyPLC to avoid State set by qualities
# explicitly added all DynamicDS properties to PyPLC
# Added DynamicCommands
# KeepAttributes,KeepTime,CheckDependencies will have its own default values for PyPLC
# Static/Mapping attributes not require polling to be up to date
#
# Revision 1.14  2011/03/23 10:33:18  sergi_rubio
# Added Mapping attributes to StaticAttributes list to be kept after an updateDynamicAttributes call.
# StateMachine() will be called once per second as much.
# import_info() calls have been removed from checkModbus to avoid DB overload.
#
# Revision 1.13  2011/03/01 19:07:22  sergi_rubio
#  * init refactoring
#
#  * solve errors in flags (Flag,!WriteFlag,!WriteBit)
#
#  * code cleanup
#
#  * thread_stop() in delete_device
#
#  * traces cleanup
#
#  * do not allow to read_mapped until all addresses read
#
#  * Binary2Denary/negBinary/Denary2Binary refactored
#
# Revision 1.12  2011/01/26 16:00:08  sergi_rubio
#
# Removed double quotes from commands dictionary.
#
# Revision 1.10  2009/01/15 16:01:20  sergi_rubio
# Modbus class should not be loaded by default, call to add_Cpp_TgClass commented
#
# Revision 1.9  2009/01/15 15:56:19  sergi_rubio
# *** empty log message ***
#
# Revision 1.8  2009/01/15 15:54:25  sergi_rubio
# WriteBit command deprecated by WriteFlag (although some backward compatibility will be provided temporarily)
#
# Bug solved in WriteFlag ... second argument now can be either int, float or string when called in DynamicAttributes declaration
#
# Revision 1.7  2008/12/18 17:09:35  sergi_rubio
# Refactoring in the initialization of the device.
# Added new property LogLevel and command SetLogLevel
#
# Revision 1.6  2008/11/13 09:39:37  taurel
# - Fix a small bug in the Coils command. The Modbus class command name
# was wrong (missing xxxMultipleCoil instead of xxxMultipleCoils)
#
# Revision 1.5  2008/11/05 17:46:49  sergi_rubio
# General refactoring of the class.
# ALBA exclusive stuff has been removed (a separate class AlbaPLC implements it).
# These release requires to checkout the last release of fandango
#
# Revision 1.4  2008/06/30 15:10:34  sergi_rubio
# Refactoring of PyPLC, new PLCValve abstract device added.
#
# Revision 1.3  2008/05/16 10:19:37  sergi_rubio
# Dozen of changes in the PyPLC and fandango modules, documentation seriously improved.
#
# Revision 1.1.1.1  2007/11/14 09:57:13  sergi_rubio
# The Device Server for Modbus PLCs
#
#
# copyleft :    ALBA Synchrotron
#               www.cells.es
#               Barcelona, EU
#
#=============================================================================
#               This file is generated by POGO
#       (Program Obviously used to Generate tango Object)
#
#         (c) - Controls Section - ALBA
#=============================================================================
#


import PyTango
import sys,time,inspect,threading,struct,re,traceback

## This device server requires Fandango, you can find the package at: http://www.tango-controls.org/Documents/tools/fandango/fandango
try: import fandango
except: import PyTango_utils as fandango

from fandango import DynamicDS,DynamicDSClass,Logger,\
  getLastException,Catched,printf
import fandango.functional as fun
from fandango.functional import *

from ModbusMap import ModbusMap,ModbusArray,ModbusMapException

#Patches between PyTango3 and PyTango7
if 'PyUtil' not in dir(PyTango): 
    PyTango.PyDeviceClass = PyTango.DeviceClass
    PyTango.PyUtil = PyTango.Util
if 'Device_4Impl' not in dir(PyTango):
    PyTango.Device_4Impl = PyTango.Device_3Impl
    
PyPLC__doc__ = """<pre>
#==================================================================
#   PyPLC Class Description:
#
#         <p>This device server will allow to interact with the Modbus PLC's.
#         The target is reading and writing variables and input/outputs of the PLC
#         by using Tango Attributes. Tango Attributes will be generated dynamically 
#         using this syntax:<br>
#         <p><pre>T3=int(Reg(7007)/10.)</pre></p>
#         <p>The commands Coil, Flag, Reg and fReg will allow to declare
#         Digital, Bit, Integer and Float variables respectively.</p>
#         <p>See full description at <a href="http://www.tango-controls.org/Members/srubio/pyplc-device-server">www.tango-controls.org</a></p>
#         <p>This device requires <a href="http://www.tango-controls.org/Documents/tools/fandango/fandango">Fandango module<a> to be available in the PYTHONPATH.
#
#==================================================================
#     Device States Description:
#
#   DevState.INIT :
#   DevState.ON :
#   DevState.ALARM :
#   DevState.FAULT :
#==================================================================

=== How Mapping works ===

Mapping property define a set of formula/comands/addresses that identify memory-mapped regions

This mappings will be accessible both by name and by modbus addresses, keeping a cache of values.

Modbus Commands to update Mappings will be executed by a background thread. 

Every time that a Modbus command is returned by the thread the Mapping flag will be enabled, telling
the device to execute ReadMap to update the cache values.

</pre>""".replace('#','')


class PyPLC(PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------

    __doc__ = PyPLC__doc__
        
    
    #This variable will limit the size of HoldingRegisters queries
    MAX_REGS_LENGTH = 120 #Changed by roberto suggestion; 30/April/2009
    
    ## Data conversion commands---------------------------------------------------
    
    #@Catched
    @staticmethod
    def negBinary(old):
        """ Given a binary number as an string, it returns all bits negated """
        return ''.join(('0','1')[x=='0'] for x in old)

    @staticmethod
    def Denary2Binary(x,N=16):
        """ It converts an integer to an string with its binary representation """ 
        if x>=0: bStr = bin(int(x))
        else: bStr = bin(int(x)%2**16)
        bStr = bStr.replace('0b','')
        if len(bStr)<N: bStr='0'*(N-len(bStr))+bStr
        return bStr[-N:]
    Dec2Bin = Denary2Binary
    
    @staticmethod
    def Binary2Denary(x,N=16):
        """ Converts an string with a binary number into a signed integer """
        i = int(x,2)
        if i>=2**(N-1): i=i-2**N
        return i
        
    @staticmethod
    def Exponent(n):
        """ Used in IeeeFloat type conversions, Converts an array of 8 binary numbers in a signed integer. """
        sum=0
        for x in range(0,8):
            sum += int(n[x])*pow(2,7-x)
        if sum == 0: return '0'
        sum = sum - 127
        return sum

    @staticmethod
    def Significand(n):
        """ Used in IeeeFloat type conversions """
        sum=0.0
        pot=1.0
        for x in range(0,24):
            sum += int(n[x])*pot/pow(2,x)
        return sum
        
    @staticmethod
    def Dec2Bits(dec,nbits=16):
        """ Decimal to binary converter """
        result,dec = [],int(dec)
        for i in range(nbits):
            result.append(bool(dec % 2))
            dec = dec >> 1
        return result        
        
    @staticmethod
    def Ints2Float(arg):
        """ Converts an array of 2 integers into an IeeeFloat number """
        #Match 0 values
        bla = int(arg[1])
        if bla  == 0 and int(arg[0]) == 0: return 0.0
        elif int(arg[0]) == -22939 and bla == 11195: return 0.0
        #Convert high bytes
        if bla >= 0: highval = PyPLC.Denary2Binary(bla)
        else:
            bla = (-1)*bla
            temp = PyPLC.Denary2Binary(bla) #"The bin value of the absolute: ",temp
            highval = PyPLC.negBinary(temp) #"The bin high value of the reverse: ", highval
        #Convert low bytes
        bla = int(arg[0])
        if bla >= 0: lowval = PyPLC.Denary2Binary(bla)
        else:
            bla = (-1)*bla;
            temp = PyPLC.Denary2Binary(bla) #print "The bin value of the absolute: ",temp
            lowval = PyPLC.negBinary(temp) #print "The bin low value of the reverse: ", lowval
        #Build result
        highval = highval + lowval
        sign = int(highval[0])
        if (sign == 0): sign1 = 1
        else: sign1 = -1
        expo = highval[1:9]
        mant = '1' + highval[9:]
        ex = int(PyPLC.Exponent(expo))
        si = float(PyPLC.Significand(mant))
        argout= float(sign1*pow(2,ex)*si)
        return argout
        
    # -----------------------------------------------------------------------------
    ## Threaded behaviour methods --------------------------------
    
    def initThreadDict(self):
        """
        It creates a ThreadDict, a dictionary of modbus commands which results will be updated periodically.
        All registers used by Mappings are by default added as keys.
        For each key it will execute a ReadHoldingRegisters modbus command,
        """
        def read_method(args,comm=self.Regs,log=self.debug):
            try:
                #log('>'*20 + ' In ThreadDict.read_method(%s)' % args)
                args = [int(s) for s in args.split(',')[:2]]
                result = comm(args,asynch=True) #If comm==self.Regs it will trigger an update of Map Flag
                ##Trying to speed up refresh for Beamlines
                #result = comm(args,asynch=False)
                return result
            except PyTango.DevFailed,e:
                print 'Exception in ThreadDict.read_method!!!'+'\n'+str(e).replace('\n','')[:100]
            except Exception,e:
                print '#'*80+'\n'+'Exception in ThreadDict.read_method!!!'+'\n'+traceback.format_exc()+'\n'+'#'*80
                return [] ## Arrays must not be readable if communication doesn't work!!!!
        self.threadDict = fandango.ThreadDict(
            read_method = read_method,
            timewait=max(0.01,self.ModbusTimeWait/1000.)
            )#trace=True)
        #self.threadDict.set_timewait(max(0.01,self.ModbusTimeWait/1000.))
        
        for var,maps in self.MapDict.items():
            md = self.MapDict[var]
            regs = md.commands
            for reg in regs:
                vals = ','.join(str(r) for r in reg)
                self.debug('Adding %s(%s) as ThreadDict[%s]' % (var,reg,vals))
                self.threadDict.append(vals,value=[],period=md.period)#period=[])
        
        self.threadDict.start()
        self.info('out of PyPLC.initThreadDict()'+'\n'+'-'*80)
        
    # -------------------------------------------------------------------------

    def parseMappingProperty(self,mapping=None,update=False):
        """
        Parsing the Mapping property and initializing MapDict dictionaries.
        """
        mapdict,mapping = {},mapping if mapping is not None else self.Mapping
        self.debug('In parseMappingProperty(%s,%s)'%(mapping,update))
        if update: 
            if not getattr(self,'MapDict',None): self.MapDict = ModbusMap()
            else: self.MapDict.clear()
            target = self.MapDict
        else: target = ModbusMap()
        try:
            target.load(mapping)
            mapdict = target.asDict()
            if update:
                for v in target.values():
                    for a in (self.DynamicAttributes,self.StaticAttributes):
                        if v.attribute not in a: a.append(v.attribute)
                self._locals['MapDict'] = self._locals['Mapping'] = self.MapDict
        except Exception,e:
            error = 'Unable to parse Mapping Property: %s'%(traceback.format_exc())
            self.init_errors.append(error), self.error(error)
        self.info("Mapping's read are: %s"%str(mapdict))
        return mapdict
        
    def ReadMap(self,*args):
        '''
        Possible arguments are:
            1 string matching the name of a Mapping:
                The formula declared for Mapping will be used for the declaration
            1 string containing Regs() commands:
                The string is used like a simple attribute declaration; the attribute is evaluated.        
            2 integers (in 2 variables or in a list or tuple):
                These are understood as the starting and ending address to be read.
                Due to Modbus limitations it splits this Map reading in sets of 125 registers.
        '''
        #self.debug('>'*80)
        t0 = time.time()
        if not args: raise Exception('ReadMap.ArgumentNeeded')
        result,attr = [],''
        
        # If the argument is the name of a Mapping we replace args and attr_name
        if args[0] in self.MapDict: 
            attr,args = args[0],[self.MapDict[args[0]].formula]
        # If first argument is not in map format, we evaluate it
        if len(args)==1 and isString(args[0]) and not ModbusArray.is_valid_map(args[0]):
            self.info('ReadMap(%s): Unrecognized format, returning a pure evaluation.'%args)
            result = self.evalAttr(args[0])
        #Matching a declared mapping, two addresses or a list of Reg commands
        else:
            self.debug('In ReadMap(%s,%s)'%(attr,args))
            if attr: regs = self.MapDict[attr].commands
            else: regs = ModbusArray.GetCommands4Map(*args)
            self.debug('ReadMap: %d reg commands: %s = %s'%(len(regs),args,regs))
            if hasattr(self,'threadDict'): #reading in background thread
                for reg in regs:
                    key = ','.join(str(r) for r in reg)
                    val = self.threadDict[key]
                    if isinstance(val,Exception):
                        raise Exception('Exception: %s[%s]: %s.' % (attr,key,str(val)) )
                    if val is None or not len(val):
                        raise ModbusMapException('ReadMapException: %s[%s] values has not been read yet.' % (attr,key) )
                    else:
                        result.extend(val)
                    #self.debug('Reading from ThreadDict[%s] = %s...'%(key,result[:10]))
            else: #reading registers immediately
                [result.extend(self.Regs([addr,length])) for addr,length in regs]
                self.debug('Reading from Modbus(%s) = %s ...' % (regs,result[:10]))
            
        #Keeping the value of Mapping for further reuse; even if the rest of attributes are not kept
        if attr in self.MapDict:
            #########################################################################
            self.dyn_values[attr].keep = True
            result = self.dyn_types[attr].pytype(result) #Data conversion necessary to avoid numpy issues
            self.debug('Updating %s cached values ([%d])'%(attr,len(result)))
            self.dyn_values[attr].update(result,self.MapDict[attr].time,PyTango.AttrQuality.ATTR_VALID)
            self.MapDict[attr].data = self.dyn_values[attr].value
            self._locals[attr] = result
            
            self.MapDict[attr].uncheck()
        self.debug( "Out of ReadMap(%s), it took %d ms" % (args,1e3*(time.time()-t0)))
        return result
                
    # -------------------------------------------------------------------------                
    
    def checkModbus(self):
        """ This method will check the modbus device and will throw exception if not available. """
        if not self.modbus:
            self.last_failed = time.time()
            self.last_exception,self.last_exception_time = "ModbusDeviceNotInitialized",self.last_failed
            raise Exception('ModbusDeviceNotInitialized(%s)'%self.Modbus_name)
        elif self.last_failed>self.last_communication:
            if not self.modbus.ping(): #Using ping to check device availability
                self.last_failed = time.time()
                self.last_exception,self.last_exception_time = "ModbusDeviceNotExportedException",self.last_failed
                raise Exception('ModbusDeviceNotExported(%s)'%self.Modbus_name)
        return True
                
    def sendModbusCommand(self,command,arr_argin,asynch=False):
        (self.debug  if asynch else printf)('In PyPLC.sendModbusCommand(%s,%s) ... %s' % (command,arr_argin,['Synch-EXTERNAL','Asynch-INTERNAL'][asynch]))
        result,retries,timeout,Xretries=None,3,1.,100.
        # WE WILL WAIT timeout/Xretries seconds between checking if the asynch has arrived
        self.last_try=time.time()
        if arr_argin is not None and len(arr_argin): arr_argin[0] += self.AddressOffset
        
        if self.ErrorTimeWait>1000*(self.last_try-self.last_failed):
            #PyTango.Except.throw_exception("TimeWAITBetweenRetries","Last communication failed at %s, waiting %s millis"%(time.ctime(self.last_failed),self.ErrorTimeWait),inspect.currentframe().f_code.co_name)
            raise Exception('%s (retry in %s ms)'%(self.last_exception,self.ErrorTimeWait))
        if not self.checkModbus(): #It will trigger an exception if Modbus is not reached
            return
        
        try:            
            ## If it is an external command (Synchronous) the threadDict must be stop to execute the external command first.
            if not asynch and hasattr(self,'threadDict'): self.threadDict.stop()        
            while retries:
                try:
                    if time.time()>(self.last_try+timeout):
                        retries = 0
                        raise Exception(self.last_exception if 'timeout' in str(self.last_exception).lower() 
                              else 'sendModbusCommand(%s,%s): Timeout!'%(command,arr_argin))
                    if not asynch:
                        try: 
                            self.debug('In PyPLC.sendModbusCommand(...): Acquiring Modbus Lock ....')
                            self.modbusLock.acquire()
                            result=self.modbus.command_inout(command,arr_argin)
                        finally:
                            self.debug('In PyPLC.sendModbusCommand(...): Releasing Modbus Lock ....')
                            self.modbusLock.release()
                    else:
                        another_retries = Xretries
                        tw = timeout/Xretries
                        cid = self.modbus.command_inout_asynch(command,arr_argin)
                        #self.debug('In PyPLC.sendModbusCommand(...): Waiting %d*%d ms for asynchronous answer (cid=%s) ...' % (Xretries,int(1000*tw),cid))
                        while another_retries:
                            another_retries -= 1
                            threading.Event().wait(tw)
                            try:
                                self.modbusLock.acquire()
                                result = self.modbus.command_inout_reply(cid)
                                self.debug('Received: %s' % (str(result)[:50]+' ...'))
                                break
                            except PyTango.DevFailed,e:
                                if 'AsynReplyNotArrived' not in str(e):
                                    self.debug('Received DevFailed: %s' %e)
                                if another_retries == 0 or any(q in str(e) for q in ('DeviceTimedOut','BadAsynPollId')): #BadAsynPollId is received once the command is discarded
                                    raise Exception,'ModbusException_%s'%(str(e).replace('\n','')[:100])
                            finally:
                                self.modbusLock.release()
                    if self.MapDict: 
                        reg = arr_argin[0] if fun.isIterable(arr_argin) else arr_argin
                        [v.check() for v in self.MapDict.values() if v.has_address(reg)]
                    self.last_exception = ''
                except Exception,e:
                    retries-=1
                    self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
                    (retries and self.debug or self.warning)(self.get_name()+"::sendModbusCommand: Exception!(%d retries left): %s" % (retries,str(e)))
                    if retries<=0:
                        self.set_state(PyTango.DevState.UNKNOWN)
                        self.last_failed=time.time()
                        #Between failed communications the retry frequency is reduced
                        if hasattr(self,'threadDict'): self.threadDict.set_timewait(max(1,self.ErrorTimeWait/1000.))
                        raise e
                    else:
                        threading.Event().wait(.2)
                        continue
                self.last_communication=time.time()
                if hasattr(self,'threadDict'): self.threadDict.set_timewait(max(0.01,self.ModbusTimeWait/1000.))
                self.last_exception,self.last_exception_time = '',0
                self.last_failed=0
                if 0.5<(self.last_communication-self.last_try):
                    self.warning('WARNING!:In PyPLC.sendModbusCommand(...): %s: Modbus communication (%s,%s) took %fms!!!'% \
                        (time.ctime(),command,str(arr_argin),1000*(self.last_communication-self.last_try)))
                self.average_read_time = self.average_read_time and (.9*self.average_read_time + .1*(self.last_communication-self.last_try)) or (self.last_communication-self.last_try)
                break #Exit while if there's no exceptions
        finally:
            ## If it is an external command (Synchronous) the threadDict must be stop to execute the external command first.
            if not asynch and hasattr(self,'threadDict'): self.threadDict.start()
        return result
                    
    # -------------------------------------------------------------------------                    
            
    #---- DynamicAttributes State Machine -----------------
    def is_dyn_allowed(self,req_type=None,attr_name=None):
        '''
        Attributes reading will not be allowed until DigitalsREAD has been updated
        '''      
        #@TODO THIS METHOD IS NEVER CALLED!?!?!
        self.debug('In PyPLC.is_dyn_allowed(%s,%s)' % (req_type,attr_name))

        if time.time() < self.time0+10.:
            #A minimum delay is required to guarantee device mappings update
            return False
          
        if attr_name in self.MapDict:
            """ These attributes will be read as ReadMap(attr_name) """
            try:
                if not hasattr(self,'threadDict'): 
                    #self.debug('In PyPLC.is_dyn_allowed(%s): mapped attributes are always allowed'%attr_name)
                    return True
                else:
                    regs = self.MapDict[attr_name].commands
                    if all(fun.isTrue(self.threadDict.get(','.join(str(r) for r in reg))) for reg in regs):
                        return True
                    else:
                        self.warning('In PyPLC.is_dyn_allowed(%s): Values not read yet'%(attr_name))
                        return False
            except Exception,e:
                self.warning('In PyPLC.is_dyn_allowed(%s): Unable to know if available: %s'%(attr_name,e))
                return False
        
        if attr_name not in self.dyn_values:
            self.warning('Dynamic Attribute (%s) does not exists!' % (attr_name))
            raise Exception('Dynamic Attribute (%s) does not exists!' % (attr_name))
            return False
        else: #DynamicAttributes dependent from Mappings will not be allowed if Mappings are empty
            missing = [m for m in self.MapDict if m in self.dyn_values[attr_name].formula and not self.dyn_values[m].value]
            if missing:
                self.info('Dynamic Attribute %s not allowed until %s will be read.' % (attr_name,missing))
                #raise Exception,'Dynamic Attribute %s not allowed until %s will be read.' % (attr_name,missing)
                return False
        return True                
        
    ###########################################################################
    # State Management methods
        
    def State(self):
        """ State redefinition is required to keep independency between 
        attribute configuration (max/min alarms) and the device State """
        #return self.get_state()
        return self._state
    
    def set_state(self,state,push=True):
        self._state = state
        DynamicDS.set_state(self,state,push=push) #PyTango.Device_4Impl.set_state(self,state)
        
    def get_state(self):
        #@Tango6
        #This have been overriden as it seemed not well managed when connecting devices in a same server
        return self._state
    
    def dev_state(self):
        #@Tango7
        #This have been overriden to avoid device servers with states managed by qualities
        return self._state
            
    def check_state(self,set_state=False): pass #Disabling DynamicState management out of always_executed_hook
    def check_status(self,set=False): pass #Disabling DynamicState management out of always_executed_hook
    
    def StateMachine(self,state=None,status=None):
        """
        The State will be ON if there has been a succesful communication in the last MAX_IDLE seconds; 
        STANDBY/UNKNOWN/FAULT depending of previous communication errors
        """
        self.debug('In PyPLC::StateMachine(%s,%s) ...'%(state,status[:80]))
        state,status = state or PyTango.DevState.ON, status or ''
        self.MAX_IDLE = 10*60
        if not self.SimulationMode:
            if not self.modbus:
                state = PyTango.DevState.UNKNOWN
                status += 'Modbus Device %s is not defined or not recognized!!!'%(self.Modbus_name)+'\n'+status
            elif not self.last_try:
                state = PyTango.DevState.UNKNOWN
                status += 'No communication has been established with the device'+'\n'+status
            elif self.last_failed:
                state = PyTango.DevState.FAULT
                status += 'Last Communication failed at %s'%time.ctime(self.last_failed)+'\n'+status
            elif self.last_communication < time.time()-self.MAX_IDLE and (self.last_communication or self.last_failed):
                state = PyTango.DevState.FAULT
                status += 'Last Communication was at %s'%time.ctime(self.last_communication)+'\n'+status
            elif not self.last_communication:
                state = PyTango.DevState.INIT
                status += 'Hardware not contacted yet.\n'+status
            else:
                state = PyTango.DevState.ON
                #status += '%s is ON.\n'%self.get_name()+status
        if str(state) not in ('UNKNOWN','FAULT','INIT') and self.last_exception_time<time.time()-600:
            self.last_exception,self.last_exception_time = '',0
        elif self.last_exception:
            status += '\nLast PyPLC Exception was at %s: \n%s' % (time.ctime(self.last_exception_time),str(self.last_exception)[:1000])
        if self.init_errors: 
            status += '\n\nINITIALIZATION ERRORS:\n\t' + '\n\t'.join(self.init_errors)
        self.debug(status)
        return (state,status)
            
    def init_parent_classes(self,cl,name):
        self.call__init__(DynamicDS,cl,name,globals(),_locals=
            {
            'Reg':             lambda _addr:             self.Reg(_addr),
            'InputReg':             lambda _addr:             self.InputReg(_addr),
            'Regs':         lambda _addr,val:         self.Regs([_addr,val]),
            'InputRegs':         lambda _addr,val:         self.InputRegs([_addr,val]),
            'Regs32':         lambda _addr,val:         self.Regs([_addr,val]),
            'Coil':         lambda _addr:            self.Coil(_addr),
            'Coils':         lambda _addr,val:        self.Coils([_addr,val]),
            'Flag':         lambda _addr,val:        self.Flag([_addr,val]),
            'IeeeFloat':     lambda _addr:            self.IeeeFloat(_addr),
            'WriteFloat':     lambda _addr,val:        self.WriteFloat([_addr,val]),
            'WriteCoil':     lambda _addr,bit:        self.WriteCoil([_addr,bit]),
            'WriteFlag':     lambda _addr,bit,val:    self.WriteFlag([_addr,bit,val]),
            'WriteBit':     lambda _addr,bit,val:    self.WriteFlag([_addr,bit,val]), #WriteBit Must Be Deprecated!
            'WriteInt':     lambda _addr,val:        self.WriteInt([_addr,val]),
            'WriteLong':     lambda _addr,val:        self.WriteLong([_addr,val]),

            'Bit':             lambda number,val:        self.Flag([number,val],HW=False),            
            'Denary2Binary': lambda num:             self.Denary2Binary(num),
            'Binary2Denary': lambda bin:            int(str(bin),2),        
            
            'ReadMap': lambda *args: self.ReadMap(*args),
            'Dec2Bits': lambda dec,n=16: self.Dec2Bits(dec,n),
            'Dec2Bin': lambda num: self.Denary2Binary(num),
            'Bin2Dec': lambda bin: int(str(bin),2),              
            }
            , useDynStates=True)
        self.call__init__(PyTango.Device_4Impl,cl,name)
            
                
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        self.StaticAttributes = []
        self.init_parent_classes(cl,name)     
        PyPLC.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        try:
          print('-'*80)
          print("[Device delete_device method] for %s"%self.get_name())
          self.set_state(PyTango.DevState.INIT)
          self.threadDict.stop()
          try: self.modbusLock.release()        
          except: pass
          del self.modbus
          threading.Event().wait(3.)
        except: traceback.print_exc()
        print('-'*80)

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self,check_polled=True,get_properties=True):
        '''
        :param check_polled: allows sub-classes to customize polled attributes verification
        :param get_properties: avoids redundant property reloading
        '''        
        print "In ", self.get_name(), "::init_device()"
        self.init_errors = []
        self.set_state(PyTango.DevState.UNKNOWN)
        if get_properties: self.get_device_properties(self.get_device_class())
        self.setLogLevel(self.LogLevel)
        
        #The STATE_MACHINE_PERIOD will control how frequently PyPLC.StateMachine will be called (within always_executed_hook)
        self.PollingCycle = max((self.KeepTime,self.get_polled_attrs().get('state',1000.))) #used to control frequency of polling status log
        self.STATE_MACHINE_PERIOD = self.PollingCycle/1e3

        # INITIALIZING MODBUS CONNNECTION
        # -----------------------------------------------------------
        self.info('Initializing Modbus connection')
        self.modbus = None
        self.modbusLock = getattr(self,'modbusLock',None) or threading.Lock()
        prop = PyTango.Database().get_device_property(self.get_name(),['Modbus_name'])
        self.Modbus_name = toList(prop.get('Modbus_name',['']))[0]
        self.last_try,self.last_failed,self.last_communication,self.average_read_time = 0,0,0,0
        self.last_exception,self.last_exception_time,self.last_state_machine = '',0,0

        if len(self.Modbus_name)>0:
            try:
                self.modbus = PyTango.DeviceProxy(self.Modbus_name)
                try: self.modbus.set_timeout_millis(1000)
                except: self.warning('Unable to set modbus timeout to 1000')
                try:
                    self.modbus.ping()
                    self.set_state(PyTango.DevState.INIT)
                except Exception,e:
                    msg = "Modbus Device %s is not working!\n%s"%(self.Modbus_name,str(e))
                    self.warning(msg),self.set_status(msg)
                    self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
            except Exception,e:
                self.modbus = None
                msg = "Modbus Device %s is not recognized!!!\n%s"%(self.Modbus_name,str(e))
                self.warning(msg),self.set_status(msg)
                self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
        else:
            msg = "Modbus Device %s is not defined!!!"
            self.error(msg),self.set_status(msg)
        
        # PARSING MAPPING PROPERTY
        # ------------------------------------------------- 
        self.parseMappingProperty(update=True)
        if self.MapDict is not None: 
            #Parsing ModbusCacheConfig Property
            if self.modbus and hasattr(self,'ModbusCacheConfig') and self.ModbusCacheConfig:
                self.SetModbusCacheConfig()
            else: self.warning("ModbusCacheConfig Property has not been defined")                
            if check_polled: self.check_polled_attributes(new_attr=dict.fromkeys(self.MapDict.keys(),3000))
            self.initThreadDict()
        
        self.info('PyPLC Ready to accept request ...')
        
    def updateDynamicAttributes(self):
        """Forces dynamic attributes update from properties.
        @warning : It will DELETE all attributes that does not appear in DynamicAttributes property or StaticAttributes list!
        """
        xmap = self.Mapping
        DynamicDS.updateDynamicAttributes(self)
        if self.Mapping!=xmap: self.parseMappingProperty(update=True)
        #The STATE_MACHINE_PERIOD will control how frequently PyPLC.StateMachine will be called (within always_executed_hook)
        self.PollingCycle = max((self.KeepTime,self.get_polled_attrs().get('state',1000.))) #used to control frequency of polling status log
        self.STATE_MACHINE_PERIOD = self.PollingCycle/1e3

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        #print "In ", self.get_name(), "::always_excuted_hook() at ",time.time()
        try:
            self.debug("In "+self.get_name()+"::always_executed_hook()"+"<"*40)
            now = time.time()
            
            #Updating Mapping values
            try:
                for k,v in self.MapDict.items():
                    if v.checked() and self.dyn_values[k].date<(now-self.KeepTime/1e3): 
                        self.debug('In always_executed_hook(): Map "%s" has new data'%k)
                        self.ReadMap(k)
            except ModbusMapException,e: self.warning("In "+self.get_name()+"::always_executed_hook():"+'Unable to update mappings: %s'%e)
            except: self.warning("In "+self.get_name()+"::always_executed_hook():"+'Unable to update mappings:\n%s'%traceback.format_exc())
                
            #State is evaluated just once per second (KeepTime property value)
            if now>(self.last_state_machine+self.STATE_MACHINE_PERIOD):
                prev,self.last_state_machine = self.get_state(),now
                #self.set_state(PyTango.DevState.ON),self.set_status('') #Default PyPLC State
                DynamicDS.always_executed_hook(self) #<= DynamicStates disabled here
                state0,status0 = self.get_state(),self.get_status() #For Logging purposes
                if self.dyn_states: 
                    state0 = DynamicDS.check_state(self,set_state=False,current=state0)
                    self.debug('DynamicStates: %s(%s)'%(type(state0),state0))
                if self.DynamicStatus: status0 = DynamicDS.check_status(self)
                state,status = self.StateMachine(state0,'')#,status0) #Communication errors override DynamicStates machine
                if state!=state0: self.debug('StateMachine: %s(%s)'%(type(state),state))
                txt = 'Device is in %s State'%str(state)
                self.set_status(txt+'\n'+status if txt not in status else status)
                if prev!=state:
                    comment = '%s.State changed: %s => %s => %s'%(self.get_name(),str(prev),str(state0),str(state))
                    try: self.SaveSnapFile(comment=comment)
                    except: pass
                    self.info( '*'*80)
                    self.info(comment)
                    self.info( '*'*80)
                self.set_state(state,push=True) #it must not be in the if!, Events will be pushed here
                self.debug('StateMachine took %d ms' % (1000*(time.time()-now)))
        
        except Exception,e:
            self.last_exception,self.last_exception_time = 'DevFailed' in str(e) and str(e) or traceback.format_exc(),time.time()
            self.error('Exception in always_executed_hook: %s'%str(e))
            print '*'*80 + '\n' +self.last_exception + '\n' + '*'*80


#==================================================================
#
#    PyPLC read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        read_attrs = DynamicDS.read_attr_hardware(self,data)
        self.debug("read_attr_hardware([%d]=%s)"%(len(data),str(read_attrs)[:80]))

#==================================================================
#
#    PyPLC command methods
#
#==================================================================

#------------------------------------------------------------------
#    Reg command:
#
#    Description: 
#    argin:  DevLong    Modbus Address
#    argout: DevLong    Value Read/Written
#------------------------------------------------------------------
    
    def Reg(self, argin):
        self.debug("In "+self.get_name()+"::Reg()")
        #    Add your own code here
        
        # The DefaultReadCommand Modbus Command uses Arrays as both Argument In and Out
        arr_argin=[argin,1]
        argout = self.sendModbusCommand(self.DefaultReadCommand,arr_argin)
        return argout[0]


#------------------------------------------------------------------
#    HoldingReg command:
#
#    Description: 
#    argin:  DevLong    Modbus Address
#    argout: DevLong    Value Read/Written
#------------------------------------------------------------------
    
    def HoldingReg(self, argin):
        self.debug("In "+self.get_name()+"::HoldingReg()")
        #    Add your own code here
        if True: #try:
            # The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
            arr_argin=[argin,1]
            argout = self.sendModbusCommand("ReadHoldingRegisters",arr_argin)
            return argout[0]


#------------------------------------------------------------------
#    InputReg command:
#
#    Description: 
#    argin:  DevLong    Modbus Address
#    argout: DevLong    Value Read/Written
#------------------------------------------------------------------
    
    def InputReg(self, argin):
        self.debug("In "+self.get_name()+"::InputReg()")
        #    Add your own code here
        # The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        arr_argin=[argin,1]
        argout = self.sendModbusCommand("ReadInputRegisters",arr_argin)
        return argout[0]


#------------------------------------------------------------------
#    @mniegowski 
#   
#    IeeeFloat command:
#
#    Description
#    argin: Modbus Address OR two int32 values to convert
#    argout: Float value of the combined two next Registers
#------------------------------------------------------------------
    
    def IeeeFloat(self,argin):
        self.debug("In "+self.get_name()+"::IeeeFloat("+str(argin)+")")
        argin = [int(i) for i in argin] if hasattr(argin,'__iter__') else argin
        try:
            #First Parse the arguments (may be an array or an address to read
            if type(argin)==type([]) and len(argin)>1:
                arg=argin[0:2]    
            else:
                if type(argin)==type([]):
                     _addr=argin[0]
                else: 
                    _addr=argin
                # The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
                arr_argin=[_addr,2]
                arg = self.sendModbusCommand("ReadHoldingRegisters",arr_argin)
            return self.Ints2Float(arg)
        except PyTango.DevFailed, e:
            self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
            self.warning('In IeeeFloat(%s):\n%s'%(argin,self.last_exception))
            #PyTango.Except.re_throw_exception(e,"DevFailed Exception",str(e),inspect.currentframe().f_code.co_name)
            #PyTango.Except.throw_exception("PyPLC_DevFailed",str(e),inspect.currentframe().f_code.co_name)
            PyTango.Except.throw_exception(str(e.args[0]['reason']),str(e.args[0]['desc']),inspect.currentframe().f_code.co_name+':'+str(e.args[0]['origin']))
        except Exception,e:
            self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
            print self.last_exception
            PyTango.Except.throw_exception(str(e),"Something wrong!",inspect.currentframe().f_code.co_name)

#------------------------------------------------------------------
#    @mniegowski 
#   
#    Coil command:
#
#    Description
#    argin: Coil Address
#    argout: Coil Status 
#------------------------------------------------------------------
    
    def Coil(self, arr_argin):
        self.debug("In %s::Coil()"%self.get_name())
        #    Add your own code here

        argout = self.sendModbusCommand("ReadCoilStatus",arr_argin)
        return argout[0]

#------------------------------------------------------------------
#    @mniegowski 
#   
#    Flag command:
#
#    Description
#    argin: Modbus Address, Number of corresponding bit
#    argout: Boolean Value
#------------------------------------------------------------------

    def Flag(self,argin,HW=True):
        """ Returns the value of the given bit within a 16bits register
        :param HW:  If True, a register will be read from the given address. 
                    If False the address will be used as register value
        :param argin[0]: The address/value of the int register
        :param argin[1]: the bit to be returned
        """
        self.debug("In %s.Flag(%s)"%(self.get_name(),argin))
        _addr = int(argin[0])# if argin[0] is not None else 0)
        n = int(argin[1])# if argin[1] is not None else 0)
        
        if 0<=n<16:
            reg = int(self.sendModbusCommand("ReadHoldingRegisters",[int(_addr),1])) if HW else _addr
            tval = self.Denary2Binary(reg)
            argout = int(tval[15-n]) 
            return argout
        else:
            PyTango.Except.throw_exception("PyPLC_IndexOutOfRange","Error:Selected Bit must be between 0 and 15",inspect.currentframe().f_code.co_name)

#------------------------------------------------------------------
#    Bit command:
#
#    Description
#    argin: Get a bit from an int (It is not accessing Hardware at all!)
#    argout: Boolean Value
#------------------------------------------------------------------
    
    def Bit(self,argin):
        return self.Flag(argin,HW=False)

#------------------------------------------------------------------
#   
#    Regs command:
#
#    Description
#    argin: Modbus Address, Number of Registers
#    argout:Read Values Array
#------------------------------------------------------------------

    def Regs(self,arr_argin,asynch=False):
        """ 
        The DefaultReadCommand Modbus Command uses Arrays as both Argument In and Out
        :param arr_argin: [_addr,n]
        """
        argout = self.sendModbusCommand(self.DefaultReadCommand,arr_argin,asynch=asynch)
        return argout
    
#------------------------------------------------------------------
#   
#    HoldingRegs command:
#
#    Description
#    argin: Modbus Address, Number of Registers
#    argout:Read Values Array
#------------------------------------------------------------------

    def HoldingRegs(self,arr_argin,asynch=False):
        """
        The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        :param arr_argin: [_addr,n]
        """
        argout = self.sendModbusCommand("ReadHoldingRegisters",arr_argin,asynch=asynch)
        return argout    
        
#------------------------------------------------------------------
#   
#    InputRegs command:
#
#    Description
#    argin: Modbus Address, Number of Registers
#    argout:Read Values Array
#------------------------------------------------------------------

    def InputRegs(self,arr_argin):
        """
        The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        :param arr_argin: [_addr,n]
        """
        argout = self.sendModbusCommand("ReadInputRegisters",arr_argin)
        return argout        


#------------------------------------------------------------------
#    @mniegowski 
#   
#    Regs command:
#
#    Description
#    argin: Modbus Address, Number of Registers * 2 
#    argout:32 bit long values
#------------------------------------------------------------------        
            
    def Regs32(self,argin):
        n = int(argin[1])*2
        _addr = argin[0]

        # The ReadHoldingRegisters Modbus Command uses Arrays as both Argument In and Out
        arr_argin=[_addr,n]
        vals = self.sendModbusCommand("ReadHoldingRegisters",arr_argin)
        argout=[0]*(n/2)
        for i in range (0,n,2):
            j = i/2
            argout[j] = 32768*int(vals[i]) + int(vals[i+1])
        return argout

#------------------------------------------------------------------
#    @mniegowski 
#   
#    Coils command:
#
#    Description
#    argin: Coil Address, Number of Coils
#    argout:Read Values Array
#------------------------------------------------------------------

    def Coils(self,arr_argin):
        argout = self.sendModbusCommand("ReadMultipleCoilsStatus",arr_argin)
        return argout



#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteInt command:
#
#    Description
#    argin: Modbus Address, Int value to be Inserted 
#    argout: OK
#------------------------------------------------------------------

    def WriteInt(self,arr_argin):
        self.debug("In WriteInt()")
        if True: #try:
            self.sendModbusCommand("PresetSingleRegister",arr_argin)
            return arr_argin[-1]

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteLong command:
#
#    Description
#    argin: Modbus Address, Int value to be Inserted 
#    argout: OK
#------------------------------------------------------------------
    
    def WriteLong(self,argin):
        self.debug("In WriteLong()")
        n = int(argin[1])
        _addr = argin[0]
        if True: #try:
            hw = int(n/32768)
            lw = int(n%32768)
            arr_argin = [_addr,2,hw,lw]
            self.sendModbusCommand("PresetMultipleRegisters",arr_argin)
            return argin[-1]

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteFloat command:
#
#    Description
#    argin: Modbus Address, and Float value to store; NOTE Remember that the value will be stored in 
#           the given and also the next register as for storing float values 32-bits are needed
#    argout: For now both inserted Values 
#------------------------------------------------------------------

            
    def WriteFloat(self,argin):        
        _addr = int(argin[0])
        v = eval(str(argin[1]))
        self.debug("In WriteFloat(%s)"%str(argin))
        try:
            p = struct.pack("!f", v)
            i = struct.unpack("!I", p)
            s = "%08x" % int(i[0])
            hw = s[:4]
            lw = s[4:]
            high = int(hw,16)
            low = int(lw,16)
            #print high, " ", low
            temph = self.Denary2Binary(high)
            templ = self.Denary2Binary(low)
            if int(temph[0]) == 1:
                bla = self.negBinary(temph)
                high = int(bla,2)
                high = (-1)*high
            if int(templ[0]) == 1:
                bla = self.negBinary(templ)
                low = int(bla,2)
                low = (-1)*low            
            arr_argin = [_addr,2,low,high]
            self.sendModbusCommand("PresetMultipleRegisters",arr_argin)
            argout =  'LW:  %d  ,  HW:  %d' % (low,high)
            #return argout
            return argin[-1]
        except PyTango.DevFailed, e:
            self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
            self.warning("In WriteFloat(%s)"%str(argin)+":"+self.last_exception)
            PyTango.Except.throw_exception(str(e.args[0]['reason']),str(e.args[0]['desc']),inspect.currentframe().f_code.co_name+':'+str(e.args[0]['origin']))
        except Exception,e:
            self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
            self.warning("In WriteFloat(%s)"%str(argin)+":"+self.last_exception)
            PyTango.Except.throw_exception(str(e),"Something wrong!",inspect.currentframe().f_code.co_name)    

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteCoil command:
#
#    Description
#    argin: Coil Address, Value to be Inserted 0/1
#    argout: OK
#------------------------------------------------------------------

    def WriteCoil(self, arr_argin):
        self.debug("In WriteCoil()")
        if (arr_argin[1]==0 or arr_argin[1]==1):
            self.sendModbusCommand("ForceSingleCoil",arr_argin)
            return arr_argin[-1]
        else: 
            PyTango.Except.throw_exception("PyPLC_IndexOutOfRange","Value must be 0 or 1",inspect.currentframe().f_code.co_name)

#------------------------------------------------------------------
#    @mniegowski 
#   
#    WriteFlag command:
#
#    Description
#    argin: Modbus Address, Number of corresponding bit, Value to be inserted
#    argout: "OK"
#------------------------------------------------------------------
    @Catched
    def WriteFlag(self,argin):
        self.info('In PyPLC(%s).WriteFlag(%s)'%(self.get_name(),argin))
        #Type casting needed to prevent exceptions (sigh!)
        addr,n,flag = [int(i) for i in argin[:3]]
        reg = None
        now = time.time()
        if 0<=n<16 and 0<=flag<=1:
            #Checking if address is cached
            for j,m in enumerate(self.MapDict.values()):
                if m and m.has_address(addr) and now<(m.time+len(self.threadDict.keys())*2*self.ModbusTimeWait):#(self.KeepTime*1e-3)):
                    reg = m.get_address(addr)
            #If address not cached:
            if reg is None:
                reg = int(self.sendModbusCommand("ReadHoldingRegisters",[addr,1])[0])
            flag = str(flag)
            binval = self.Denary2Binary(reg)
            argout = binval[:15-n] + flag + binval[16-n:]
            ins = self.Binary2Denary(argout)
            self.info("Writing into the %d register: %s = %s"%(addr,argout,ins))
            self.sendModbusCommand("PresetSingleRegister",[addr,ins])
            return argin[-1]
        else:
            PyTango.Except.throw_exception("PyPLC_IndexOutOfRange","Wrong Input",inspect.currentframe().f_code.co_name)        

#------------------------------------------------------------------
#    srubio@cells.es 
#   
#    SetModbusCacheConfig command:
#
#    Description
#    argin: 
#    argout: 
#------------------------------------------------------------------

    def SetModbusCacheConfig(self):
        '''
        This method should inspect the ranges declared in Mapping Property and setup 
        the Modbus CacheConfig Property to read this addresses in a period shorter than the polling period.
        '''
        if self.modbus and self.MapDict :
            try:
                mcc = self.ModbusCacheConfig if hasattr(self,'ModbusCacheConfig') and self.ModbusCacheConfig else "1000"
                self.debug("ModbusCacheConfig: %s"%mcc)
                if not isinstance(mcc,str) or not any(c in mcc.lower() for c in ['no','false']):
                    self.info('Configuring %s CacheConfig and ConfigSleep.' % self.Modbus_name)
                    comms,cache_config = [],[]
                    for k,vmap in self.MapDict.items():
                        comms.extend(vmap.commands)
                    if comms:
                        self.info('Updating %s properties. Commands in Mapping are: %s' % (self.Modbus_name,comms))
                        db = PyTango.Database()
                        new_props,old_props = {},db.get_device_property(self.Modbus_name,['CacheConfig','CacheSleep','_UsedBy'])
                        old_comms,i,n = [],0,len(old_props['CacheConfig'])
                        while i<n:
                            if i<n-1:#0%3==1 and i<n-1:
                                val1,val2 = tuple(old_props['CacheConfig'][i:i+2])
                                if val1.isdigit() and val2.isdigit():
                                    values = (int(val1),int(val2),)
                                    if values in old_comms: 
                                        self.warning('Mapping %s is repeated in ModbusCacheConfig!'%str(values))
                                    else:
                                        cache_config.extend(['ReadHoldingRegisters',str(values[0]),str(values[1])])
                                        old_comms.append(values)
                                        self.debug('Regs(%d,%d) Read from %s Cache Config' % (values[0],values[1],self.Modbus_name))
                                #else: self.warning('Invalid values in Modbus(%s) Cache Config' % self.Modbus_name)
                            i+=1
                        self.debug('Mapping obtained from %s Cache Config: %s' % (self.Modbus_name,old_comms))
                        
                        for comm in sorted(comms):
                            if comm not in old_comms:
                                cache_config.extend(['ReadHoldingRegisters',str(comm[0]),str(comm[1])])
                                self.debug('Regs(%s,%s) added to %s Cache Config' % (comm[0],comm[1],self.Modbus_name))
                            else: 
                                self.debug('Regs(%s,%s) already in %s Cache Config' % (comm[0],comm[1],self.Modbus_name))
                        
                        period = int(mcc) if str(mcc).isdigit() \
                            else (old_props['CacheSleep'][0] if old_props['CacheSleep'] else 1000)
                        used = old_props['_UsedBy'] + [self.get_name()] if self.get_name() not in old_props['_UsedBy'] else []
                        db.put_device_property(self.Modbus_name,{'CacheConfig':cache_config,'CacheSleep':[period],'_UsedBy':used})
                        
                        if len(cache_config)!=len(old_props['CacheConfig']): 
                            #THIS IS HARMFUL!!! MODBUS DEVICE DOES NOT CLOSE CONNECTIONS IN init();
                            #WHEN EXECUTED 3 TIMES IT HUNGS THE PLC!!!
                            #self.info('Restarting Modbus device to update CacheConfig ...')
                            #self.Reconnect()
                            self.info('Modbus Device Server must be fully restarted to update CacheConfig ...')
                        
                        return "DONE\n%s.CacheConfig:\n%s\n\nModbus SERVER must be FULL restarted now." % \
                            (self.Modbus_name,'\n'.join(cache_config))
                    else: 
                        self.info('NO Modbus Commands in Mapping property.')
                        return "NOTHING TO DO"
                else: 
                    self.info('NOT Configuring %s CacheConfig and ConfigSleep.' % self.Modbus_name)
                    return "NOT ALLOWED"
            except Exception,e:
                self.last_exception,self.last_exception_time = traceback.format_exc(),time.time()
                self.error("Exception in PyPLC.SetModbusCacheConfig: %s" % self.last_exception)
                return "EXCEPTION: %s" % self.last_exception
        return "MODBUS NOT INITIALIZED"

#------------------------------------------------------------------
#    srubio@cells.es 
#   
#    Reconnect command:
#
#    Description
#    argin: 
#    argout: 
#------------------------------------------------------------------

    def Reconnect(self):
        '''
        THIS IS HARMFUL!!! MODBUS DEVICE DOES NOT CLOSE CONNECTIONS IN init();
        WHEN EXECUTED 3 TIMES IT HUNGS THE PLC!!!
        This Command executes Init() and State() calls in the Modbus Device.
        '''
        raise Exception, \
            "MODBUS.init() IS HARMFUL!!! MODBUS DEVICE DOES NOT CLOSE CONNECTIONS IN init();"+\
            "\nWHEN EXECUTED SEVERAL TIMES IT MAY HUNG THE PLC!!!"+\
            "\n RESTART MODBUS USING ASTOR INSTEAD"


#------------------------------------------------------------------
#    srubio@cells.es 
#   
#    SaveSnapFile command:
#
#    Description
#    argin: filename
#    argout: filename
#------------------------------------------------------------------

    def SaveSnapFile(self,argin='',comment=''):
        """
        This method saves the content of Mappings in filename.
        If no filename is given the SnapFile property is used.
        Filenames would be like PyPLC_$DEVICE_$DATE.stamp
        """
        try:
            filename = (argin.strip() or self.SnapFile)
            if filename:
                date = fandango.time2str().replace('-','').replace(':','').replace(' ','')
                device = self.get_name().replace('/','_').replace('-','_').upper()
                filename = filename.replace('$DEVICE',device).replace('$DATE',date)
                self.info('SaveSnapFile(%s): Saving attribute values to %s'%(
                  comment,filename))
                data = '#'+fandango.time2str()+':'+str(comment)+'\n\n'
                data+=('%s = {\n\n'%device)
                data+=('"Name" : "%s",\n\n'%str(self.get_name()))
                data+=('"State" : "%s",\n\n'%str(self.get_state()))
                data+=('"Status" : """%s""",\n\n'%str(self.get_status()))
                for k,v in sorted(self.dyn_values.items()):
                    vv = fandango.str2type(v.value,sep_exp='')
                    if fandango.isString(vv): vv = vv.replace('\n',';')
                    value = {'value':vv,'date':v.date,'quality':str(v.quality)}
                    value['date'] = v.date
                    value['quality'] = str(v.quality)
                    value['type'] = str(getattr(v.type,'labels',[v.type])[0])
                    data+=('"%s" : \n%s\n,\n\n'%(k,repr(value)))
                data+=('}')
                if ':' in filename:
                    try:
                      fandango.device.FolderAPI().save(filename,filename,data,asynch=True)
                    except:
                      self.warning(traceback.format_exc())
                else:
                    f = open(filename,'w')
                    f.write(data)
                    f.close()
            return filename
        except:
            self.warning('Exception at SaveSnapFile(%s):\n%s'%(filename,traceback.format_exc()))
            if argin.strip(): raise

#==================================================================
#
#    PyPLCClass class definition
#
#==================================================================
class PyPLCClass(PyTango.PyDeviceClass):
    
    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'Modbus_name':
            [PyTango.DevString,
            "The name of the Modbus Tango Device used to communicate with the PLC.\nAll the information related to the communication must be specified using the \nModbus device properties.",
            [] ],
        'LogLevel':
            [PyTango.DevString,
            "Default console output configuration.",
            ["INFO"] ],
        'MaxModbusQuerySize':
            [PyTango.DevLong,
            "Maximum amount of data that can be asked in a single Modbus request.",
            [120] ],
        'Mapping':
            [PyTango.DevVarStringArray,
            "Arrays to be permanently updated, declared like : ARRAY:0,+120  #(VarName:StartAddress,+ArrayLength)",
            [] ], 
        'ModbusCacheConfig':
            [PyTango.DevLong,
            "If ModbusCacheConfig>0 then it will update CacheConfig and CacheSleep properties of the Modbus device using Mapping values.",
            [0] ],
        'ModbusTimeWait':
            [PyTango.DevLong,
            "Number of milliseconds to wait between asynchronous Modbus calls",
            [50] ],
        'DefaultReadCommand':
            [PyTango.DevString,
            "Default read command executed by Reg and Regs commands",
            ["ReadHoldingRegisters"] ],            
        'AddressOffset':
            [PyTango.DevLong,
            "Integer offset added to Addresses in every Modbus command call.",
            [0] ],        
        'ErrorTimeWait':
            [PyTango.DevLong,
            "Number of milliseconds between retries after a Modbus error",
            [10000] ],
        'SimulationMode':
            [PyTango.DevBoolean,
            "If True then modbus commands are ignored and only virtual attributes are evaluated.",
            [False] ],
        #Properties from DynamicDS class, default values tuned
        'DynamicAttributes':
            [PyTango.DevVarStringArray,
            "Attributes and formulas to create for this device.\nThis Tango Attributes will be generated dynamically using this syntax:\nT3=int(Reg(7007)/10.)\nThe commands Coil; Flag; Reg and fReg will allow to declare \nDigital; Bit; Integer and Float variables respectively.",
            [] ],
        'DynamicStates':
            [PyTango.DevVarStringArray,
            "This property will allow to declare new States dinamically based on\ndynamic attributes changes. The function Attr will allow to use the\nvalue of attributes in formulas.\n\nALARM=Attr(T1)>70\nOK=1",
            [] ],
        'DynamicQualities':
            [PyTango.DevVarStringArray,
            "This property will allow to declare formulas for Attribute Qualities.",
            [] ],
        'DynamicStatus':
            [PyTango.DevVarStringArray,
            "Each line generated by this property code will be added to status",
            [] ],
        'KeepAttributes':
            [PyTango.DevVarStringArray,
            "This property can be used to store the values of only needed attributes; values are 'yes', 'no' or a list of attribute names",
            ['yes'] ],
        'KeepTime':
            [PyTango.DevDouble,
            "The kept value will be returned if a kept value is re-asked within this milliseconds time (Cache).",
            [ 500 ] ],
        'CheckDependencies':
            [PyTango.DevBoolean,
            "This property manages if dependencies between attributes are used to check readability.",
            [True] ],
        'UseEvents':
            [PyTango.DevVarStringArray,
            "Value of this property will be yes/true,no/false or a list of attributes that will trigger push_event (if configured from jive)",
            ['false'] ],
        'LogLevel':
            [PyTango.DevString,
            "This property selects the log level (DEBUG/INFO/WARNING/ERROR)",
            ['INFO'] ],
        'SnapFile':
            [PyTango.DevString,
            "File were all attribute values will be saved on device state change, e.g. /tmp/PyPLC_$DEVICE_$DATE.stamp",
            [''] ],
        }


    #    Command definitions
    cmd_list = {
        'Reg':
            [[PyTango.DevShort, "Modbus Address"],
            [PyTango.DevShort, "Value of the register"]],
        'HoldingReg':
            [[PyTango.DevShort, "Modbus Address"],
            [PyTango.DevShort, "Value of the register"]],                
        'InputReg':
            [[PyTango.DevShort, "Modbus Address"],
            [PyTango.DevShort, "Value of the register"]],            
        'IeeeFloat':
            #[[PyTango.DevShort, "Modbus Address"],
            [[PyTango.DevVarLongArray, "Modbus Address OR two int32 to convert"],
            [PyTango.DevDouble, "Float Value obtained"]],
        'Coil':
            [[PyTango.DevShort, "Coil Address"],
            [PyTango.DevShort, "Status of Coil"]],
        'Flag':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Flag"],
            [PyTango.DevShort, "Value of the flag in the given Address"]],
        'Bit':
            [[PyTango.DevVarShortArray, "Bit(int,bit): Get a bit from an int (It is not accessing Hardware at all!)"],
            [PyTango.DevShort, "Bit(int,bit): Get a bit from an int (It is not accessing Hardware at all!)"]],            
        'Regs':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarShortArray, "Spectrum of read Values"]],
        'HoldingRegs':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarShortArray, "Spectrum of read Values"]],             
        'InputRegs':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarShortArray, "Spectrum of read Values"]],            
        'Regs32':
            [[PyTango.DevVarShortArray, "Modbus Address, Nb of Registers"],
            [PyTango.DevVarLongArray, "Spectrum of read Values"]],
        'Coils':
            [[PyTango.DevVarShortArray, "Coil Address, Nb of coils"],
            [PyTango.DevVarShortArray, "Status of Coils"]],
        'WriteInt':
            [[PyTango.DevVarShortArray, "Modbus Address, Int Value"],
            [PyTango.DevShort, "Written value"]],
        'WriteLong':
            [[PyTango.DevVarLongArray, "Modbus Address, Long Value"],
            [PyTango.DevLong, "Written value"]],
        'WriteFloat':
            [[PyTango.DevVarStringArray, "Modbus Address, Float Value to be written"],
            [PyTango.DevString, "Written value"]],
        'WriteCoil':
            [[PyTango.DevVarShortArray, "Coil Address, Value - 0/1"],
            [PyTango.DevShort, "Written value"]],
        'WriteFlag':
            [[PyTango.DevVarShortArray, "Modbus Address, Bit to Modify, New Bit Value 0/1"],
            [PyTango.DevShort, "Written value"]],

        'updateDynamicAttributes':
            [[PyTango.DevVoid, "It will DELETE all attributes that does not appear in DynamicAttributes property or StaticAttributes list!"],
            [PyTango.DevVoid, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'evaluateFormula':
            [[PyTango.DevString, "formula to evaluate"],
            [PyTango.DevString, "result"],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'isLocked':
            [[PyTango.DevVoid, ""],
            [PyTango.DevBoolean, "lock status"],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'Lock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
         'Unlock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'setLogLevel':
            [[PyTango.DevString, "DEBUG,INFO,WARNING,ERROR"],
            [PyTango.DevVoid, "Modifies the console output of the device server."],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
       'SetModbusCacheConfig':
            [[PyTango.DevVoid, "This command will update the CacheConfig and CacheSleep properties of the Modbus device."],
            [PyTango.DevString, "This command will update the CacheConfig and CacheSleep properties of the Modbus device."],
            {
                'Display level':PyTango.DispLevel.EXPERT,
            } ],
       'Reconnect':
            [[PyTango.DevVoid, "This Command executes Init() and State() calls in the Modbus Device."],
            [PyTango.DevString, "This Command executes Init() and State() calls in the Modbus Device."],
            {
                'Display level':PyTango.DispLevel.EXPERT,
            } ],
        'SaveSnapFile':
            [[PyTango.DevString, "Save attribute values to file like PyPLC_$DEVICE_$DATE.stamp"],
            [PyTango.DevString, "Save attribute values to file like PyPLC_$DEVICE_$DATE.stamp"],
            {
                'Display level':PyTango.DispLevel.EXPERT,
            } ],
        }


    #    Attribute definitions
    attr_list = {
        }


#------------------------------------------------------------------
#    PyPLCClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.PyDeviceClass.__init__(self, name)
        self.set_type(name);
        print "In PyPLCClass  constructor"


#==================================================================
#
#    PyPLC class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = ('PyUtil' in dir(PyTango) and PyTango.PyUtil or PyTango.Util)(sys.argv)
        from fandango.interface import FullTangoInheritance
        PyPLC,PyPLCClass = FullTangoInheritance('PyPLC',PyPLC,PyPLCClass,DynamicDS,DynamicDSClass,Exclude=['Lock','Unlock','isLocked'],ForceDevImpl=True)
        #srubio: it has been added for backward compatibility
        PyPLC.WriteBit,PyPLCClass.cmd_list['WriteBit']=PyPLC.WriteFlag,[[PyTango.DevVarShortArray, "DEPRECATED, Use WriteFlag instead"], [PyTango.DevVoid, "DEPRECATED, Use WriteFlag instead"]]

        if 'Modbus' in  PyTango.Database().get_device_class_list('PyPLC/%s'%sys.argv[1]):
            try: py.add_Cpp_TgClass('Modbus','Modbus')
            except: print 'Modbus Class not loaded'
        py.add_TgClass(PyPLCClass,PyPLC,'PyPLC')
        
        U = PyTango.Util.instance()
        fandango.dynamic.CreateDynamicCommands(PyPLC,PyPLCClass)
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '__main__ -------> Received a DevFailed exception:',e
        traceback.print_exc()
    except Exception,e:
        print '__main__ -------> An unforeseen exception occured....',e
        traceback.print_exc()
else:
    from fandango.interface import FullTangoInheritance
    PyPLC,PyPLCClass = FullTangoInheritance('PyPLC',PyPLC,PyPLCClass,DynamicDS,DynamicDSClass,Exclude=['Lock','Unlock','isLocked'],ForceDevImpl=True)
    #srubio: it has been added for backward compatibility
    PyPLC.WriteBit,PyPLCClass.cmd_list['WriteBit']=PyPLC.WriteFlag,[[PyTango.DevVarShortArray, "DEPRECATED, Use WriteFlag instead"], [PyTango.DevVoid, "DEPRECATED, Use WriteFlag instead"]]
